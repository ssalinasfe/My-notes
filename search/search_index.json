{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Notas de Poyllla","text":"<p>Esto es una parte de las notas que hice durante del doctorado, aqu\u00ed sub\u00ed las notas que sean solo de polylla, con el proposito que sea util para mis tesistas.</p> <p>En proyectos se encuentra la nota principal a cada versi\u00f3n de polylla</p> <p>En 00 Zettlers se encuentras las notas. El nombre deriva del m\u00e9todo que se uso para crear y organizar las notas que se llama zettelkasten, con el software Obsidian.</p> <p>Si falta alguna nota, por favor avisar. </p> <p>Sergio</p>"},{"location":"00%20Zettlers/22-04-16-0011.%20The%20terminal-face%20should%20exist/","title":"22 04 16 0011. The terminal face should exist","text":"<p>[!INFO] Date:  Saturday 16 of April, 2022 (22-04-16) Hour: 02:59 AM Title: The terminal-face should exist UID: 220416020452 Status: #idea Tags: [[22-04-14-0011. Mesh generation]] 22-11-07-1111. 3D Polylla Face 22-04-31-0011. (LFPP) Longest-face progragation path 3D </p>"},{"location":"00%20Zettlers/22-04-16-0011.%20The%20terminal-face%20should%20exist/#the-terminal-face-should-exist","title":"The terminal-face should exist","text":"<p>Cada arista de un [[tetrahedron]] est\u00e1 conectado a al menos 3 [[tetrahedron]], esto \u00faltimo hace que las 22-06-01-0011. Terminal-face regions en tengan m\u00e1s de una [[terminal-edge]].</p> <p>Por el contrario, en el caso de las [[face]]s de un tetrahedrio, como cada [[face]]s est\u00e1 conectada a una sola [[face]], entonces deber\u00eda existir una terminal-face region.</p>"},{"location":"00%20Zettlers/22-04-16-0011.%20The%20terminal-face%20should%20exist/#references","title":"References","text":""},{"location":"00%20Zettlers/22-04-19-0011.%20Nancy%20Hitschfeld-Kahler/","title":"22 04 19 0011. Nancy Hitschfeld Kahler","text":"<p>[!INFO] Zettler Date:  Tuesday 19 of April, 2022 (22-04-19) Hour: 04:01 PM Title: Nancy Hitschfeld-Kahler UID: 220419160400 Tags: [[Researchers]] [[Persons]]</p>"},{"location":"00%20Zettlers/22-04-19-0011.%20Nancy%20Hitschfeld-Kahler/#nancy-hitschfeld-kahler","title":"Nancy Hitschfeld-Kahler","text":"<p>Profesora jefa tesis m\u00eda. Se encarga de todo lo que es  - Email: nancy@dcc.uchile.cl - Google Schoolar - https://users.dcc.uchile.cl/~nancy/</p> <p>![[Pasted image 20220502130858.png]]</p>"},{"location":"00%20Zettlers/22-04-19-0011.%20Nancy%20Hitschfeld-Kahler/#references","title":"References","text":""},{"location":"00%20Zettlers/22-04-31-0011.%20%28LFPP%29%20Longest-face%20progragation%20path%203D/","title":"(LFPP) Longest-face progragation path 3D","text":"<p>Si se puede usar el lepp en 2d usando las aristas de un triangulo, en el caso de las mallas polyhedrales, se deber\u00eda poder hacer usando las caras.</p>"},{"location":"00%20Zettlers/22-04-31-0011.%20%28LFPP%29%20Longest-face%20progragation%20path%203D/#preguntas","title":"Preguntas:","text":"<ul> <li>Qu\u00e9 m\u00e9trica usar para unir tetrahedrons? Usar el \u00e1rea de una cara? R: S\u00ed funciona</li> <li>Existe un terminal-face o son varios? 22-04-16-0011. The terminal-face should exist</li> <li>De existir un terminal-face region, este genera polyhedros sin overlap? [[Demostration  terminal-face region does not overlap]]</li> <li>Demostrar que la existencias de [[Frontier-face]] Esto solo se hjace por definici\u00f3n</li> <li>Son todos los conceptos del Polylla 2d aplicables a un LFPP? [[Similarities between 2D Polylla and 3D polylla]]</li> <li>Cu\u00e1les fueron los problemas que tuvo Cecilia con LFPP? Nunca lo intento, seg\u00fan ella, esto a\u00fan no define, hay que sacar paper luego</li> </ul>"},{"location":"00%20Zettlers/22-04-31-0011.%20%28LFPP%29%20Longest-face%20progragation%20path%203D/#todo","title":"Todo","text":"<ul> <li>generar una malla de polyhedros en tengen y ver si existe un LFPP 22-11-07-1111. 3D Polylla Face</li> </ul>"},{"location":"00%20Zettlers/22-04-31-0011.%20%28LFPP%29%20Longest-face%20progragation%20path%203D/#references","title":"References","text":""},{"location":"00%20Zettlers/22-05-26-0011.%20GPU%20parallel%20Travel%20phase/","title":"GPU parallel Travel phase","text":"<p>Creation::  Thursday 26 of May, 2022.  09:33 PM date:: 22-05-26 UID:: 220526210501 Tags:: GPolylla (GPU polylla)</p> <p>Creo que se puede paralelizar la travel phase de GPolylla (GPU polylla). Para ello se asigna un thread a cada arista y est\u00e1 se encarga de actualizar sus next y prev</p> <pre><code>Kernel TravelPhase\n\nFor each half edge he \\in E:\n    if he is not frontier-edge:\n        he -&gt; prev = buscar prev frontier-edge\n        he -&gt; next = buscar next frontier-edge\n    else\n        e = next(he)\n        he -&gt; next = buscar next frontier-edge\n        e = prev(he)\n        he -&gt; prev = buscar prev frontier-edge\n</code></pre> <p>Buscar prev es un viaje ccw con respecto al origen, buscar next frontier-edge es un viaje cw con respecto al target. Para equilibrar los hilos, se puede hacer el next y prev por separado o con barreras entre medio</p> <p>El problema de esto,  es que se necesita buscar la forma de definir un \u00fanico frontier-edge del polygono como generador de polygono. Se podr\u00eda usar 22-05-26-0011. Parallel reduction para almacenar el frontier-edge con menor indice c\u00f3mo generador del polygono.</p> <p>Otra idea, lanzar un kernel antes de la travel phase, que haga la operaci\u00f3n search_frontier_edge y genere un arreglo con los indices de los frontier-edge que generan cada pol\u00edgono</p> <pre><code>Kernel Generadores\n\nFor each s in seed_edgee:\n    return search_frontier_edge(e);\n\n\nLlamar a kernel generadores para rellenar output_seeds\n</code></pre>"},{"location":"00%20Zettlers/22-05-26-0011.%20GPU%20parallel%20Travel%20phase/#references","title":"References","text":""},{"location":"00%20Zettlers/22-05-26-0011.%20Parallel%20reduction/","title":"Parallel reduction","text":"<p>Creation::  Thursday 26 of May, 2022.  09:39 PM date:: 22-05-26 UID:: 220526210550 Tags:: [[22-04-19-0011. Parallel Computing]] </p> <p>Algoritmos para combinar elementos de un array (usando operaciones binarias como suma, resta, max, etc) para conseguir un \u00fanico elemento.</p> <p>![[Pasted image 20220526214418.png]]</p>"},{"location":"00%20Zettlers/22-05-26-0011.%20Parallel%20reduction/#references","title":"References","text":""},{"location":"00%20Zettlers/22-05-26-0011.%20Parallel%20reduction/#-parallel-reduction-with-cuda-finding-the-minimum-of-very-large-by-shreeraman-karikalan-medium","title":"- Parallel Reduction with CUDA. Finding the minimum of very large\u2026 | by shreeraman karikalan | Medium","text":""},{"location":"00%20Zettlers/22-05-27-1138.%20Tiempos%20y%20memoria%20Polylla/","title":"Tiempos y memoria Polylla","text":"<p>Creation::  Friday 27 of May, 2022.  11:38 AM date:: 22-05-27 UID:: 220527110533 Tags:: Polylla</p> <p>Tiempo stimado polylla:</p> <ul> <li>Para mallas de 10000000, se demora 54 minutos (la travel phase y reparation fueron 53) y aprox 4.3 gb de ram</li> </ul> <p>Triangulation generated 39900.8 ms Labered max edges in 11129.1 ms Labeled frontier edges in 3121.62 ms Labeled seed edges in 3958.4 ms Polygons generated/repaired in 3.21056e+06 ms Mesh with 3223018 polygons 13224320 edges and 197943 barrier-edge tips.</p>"},{"location":"00%20Zettlers/22-05-27-1138.%20Tiempos%20y%20memoria%20Polylla/#references","title":"References","text":""},{"location":"00%20Zettlers/22-05-31-0011.%20PyVista/","title":"PyVista","text":"<p>Creation::  Tuesday 31 of May, 2022.  11:53 AM date:: 22-05-31 UID:: 220531110578 Tags:: [[Python]] [[Mesh visualization]]</p> <p>Python module for [[vtk]]. Permite usar [[vtk]] para visualizar mallas por partes, tiene un modulo 22-05-31-0011. Tetgen-Pyvista para generar [[Tetrahedral mesh]]es usando 22-05-31-0011. TetGen.</p> <ul> <li>Para generar un [[Delaunay 3D]] delaunay_3d \u2014 PyVista 0.34.1 documentation</li> <li>Mallas de ejemplo Load and Plot from a File \u2014 PyVista 0.34.1 documentation</li> <li></li> </ul>"},{"location":"00%20Zettlers/22-05-31-0011.%20PyVista/#links","title":"Links","text":"<ul> <li>PyVista \u2014 PyVista 0.34.1 documentation</li> <li>tetgen \u2014 tetgen 0.5.5 documentation</li> </ul>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/","title":"TetGen","text":"<p>Creation::  Tuesday 31 of May, 2022.  12:11 PM date:: 22-05-31 UID:: 220531120529 Tags:: [[22-04-14-0011. Mesh generation]] [[Software]]</p> <p>Software para generar mallas tetrahedrales de [[Delaunay tetrahedralization]] y [[Weighted Delaunay Tetrahedralization]], como tambi\u00e9n el [[Dual graph]] de ambos, [[Voronoi Diagram]] y [[Power Diagram]]. </p> <p>Dado un [[3D Polyhedral domain]], Tetgen es capaz de generar una [[constrained Delaunay tetrahedralization]] y una [[isotropic adaptive tetrahedral]]</p> <p>En Tetgen las faces y edges son respetados, pero </p> <p>Las mallas de tetgen son mejores que las del resto, esto se puede ver en 22-06-01-0011. Pymesh#Diferencias cgal y tetgen en pymesh.</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#mostrar-neighbors-caras-interiores","title":"Mostrar neighbors caras interiores","text":"<p>Para mostrar las neighs de las caras se debe usar -nn y para mostrar las caras interiores es -f. Ver 22-06-01-0011. face file</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#tetrahedrizar-mallas-de-superficies","title":"Tetrahedrizar mallas de superficies","text":"<p>Si la superficie tiene hoyos, por ejemplo, oxford bunny, o no es cerrada, tetgen no puede adivinar como cerrarla, por lo que va a generar una malla vac\u00eda.</p> <p>Pero es posible con comando -c generar el convexhull de esa figura.</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#archivos-soportados","title":"Archivos soportados","text":"<p>Tiene como input un PLC, como output un 22-06-01-0011. face file, 23-04-20-1304. ele file, [[node file]], 22-10-06-1110. edge file</p> <p>De usar software dedicado a [[Mesh visualization]]:</p> <p>Tetgen puede leer archivos en .off, .mesh and .ply</p> <p>De output tiene .mesh y .vtk</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#visualizar-mallas","title":"Visualizar mallas","text":"<ul> <li>Se puede visualizar las mallas en [[22-04-31-0011. Paraview]] dando mallas de output en formato [[vtk]] usando el comando</li> </ul> <pre><code>tetgen -p -k example.poly\n</code></pre>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#imprimir-aristas-y-caras-interiores","title":"Imprimir aristas y caras interiores","text":"<p>Para imprimir caras interiores se debe usar el formato -f, de otra forma solo se mostraran las boundary faces.</p> <p>TetGen default only outputs the boundary faces or the convex hull faces into a .face file. If the -f switch is used, TetGen outputs all faces (including interior faces) of the tetrahedralization. In this case, each interior face will always have a \u20180\u2019 as its boundary marker. This file can be omitted by using the -F switch.</p> <p>The -f switch outputs all triangular faces (including interior faces) of the mesh into a .face file.  Without -f, only the boundary faces or the convex hull faces are output. In the .face file, interior faces and boundary (or convex hull) faces are distinguished by their boundary markers. Each interior face has a boundary marker \u20180\u2019. A non-zero boundary marker means a boundary or convex hull face.</p> <p>Adem\u00e1s si se agrega el comando -nn se van agregar dos indices, despu\u00e9s del boundary marker, correspondientes a los indices de los tetrahedros del archivo .ele adyacentes a esa cara</p> <p>If the -nn switch is used, each face contains two additional indices (after the boundary marker) in the corresponding .ele file. They are indices of the tetrahedra containing this face. A \u22121 indicates that there is no adjacent tetrahedron at this side, i.e., it is \u201couter space\u201d.</p> <p>En el caso de las aristas, para imprimir aristas interiores, debe ser con -e</p> <p>The -e switch outputs all mesh edges (including interior edges) of the mesh into a .edge file.  Without -e, only the boundary edges are output. In the .edge file, interior edges and boundary edges are distinguished by their boundary markers. Each interior edge has a boundary marker \u20180\u2019. A non-zero boundary marker means a boundary edge.</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#orden-vecindad-neigh","title":"Orden vecindad (.neigh)","text":"<p>Al igual que [[Triangle - Shewchuk]], los .neighs en Tetgen tienen  un orden especifico, este que el primer neighbor es el opuesto al de la esquina</p> <p>The -n switch outputs the neighboring tetrahedra to a .neigh file. Each tetrahedron has four neighbors.  The first neighbor of this tetrahedron is opposite to the first of its corner, and so on. The neighbors are given by their indices in the corresponding .ele file. A \u2018-1\u2019 indicates that there is no neighbor at this face of the tetrahedron.</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20TetGen/#references","title":"References","text":"<p>[1]  Tetgen PDF manual https://wias-berlin.de/software/tetgen/1.5/doc/manual/manual.pdf</p>"},{"location":"00%20Zettlers/22-05-31-0011.%20Tetgen-Pyvista/","title":"Tetgen-Pyvista","text":"<p>Creation::  Tuesday 31 of May, 2022.  12:04 PM date:: 22-05-31 UID:: 220531120576 Tags:: </p> <p>Modulo para 22-05-31-0011. TetGen de 22-05-31-0011. PyVista.</p> <p>A considerar:</p> <ul> <li>Solo exporta en formato VTK</li> </ul>"},{"location":"00%20Zettlers/22-05-31-0011.%20Tetgen-Pyvista/#links","title":"Links","text":"<ul> <li>API Reference \u2014 tetgen 0.5.5 documentation</li> </ul>"},{"location":"00%20Zettlers/22-06-01-0011.%203D%20polylla%20Face%20phases/","title":"3D polyllas phases","text":"<p>Creation::  Wednesday 01 of June, 2022.  08:06 PM date:: 22-06-01 UID:: 220601200626 Tags:: 22-11-07-1111. 3D Polylla Face</p> <p>Las phases para generar una malla 3D de polylla son:</p> <ul> <li>22-06-07-1706. 3D Label phase: Similar a la [[Label phase]] en 2D, se etiquetan cada cara de la malla de tetrahedros inicial como [[Frontier-face]], si la cara es de borde, se etiqueta como Frontier-face tambi\u00e9n</li> <li>22-06-01-0011. 3D travel phase: Est\u00e1 es distinta a la [[Travel phase]] en 2D, aqu\u00ed por cada frontier-face, se le cambian las adjacencias de sus caras vecinas. [[How many faces has a 3d polylla polygon?]] </li> <li>22-06-15-1106. 3D repair phase Polylla Face: Similar a la [[Repair phase]] en 2D, calcula la valencia de una [[Barrier-face tip]] y elige la [[middle-face]], para convertir un [[interior-face]] en [[Frontier-face]] Puede que existan casos degenerados [[What are the degenerates cases generates by converting terminal-face regions to polyhedrons]]</li> </ul>"},{"location":"00%20Zettlers/22-06-01-0011.%203D%20polylla%20Face%20phases/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-01-0011.%203D%20travel%20phase/","title":"3D travel phase","text":"<p>Creation::  Wednesday 01 of June, 2022.  08:18 PM date:: 22-06-01 UID:: 220601200619 Tags:: 22-06-01-0011. 3D travel phase 22-06-01-0011. 3D polylla Face phases 22-11-07-1111. 3D Polylla Face</p> <p>Fase en de la generaci\u00f3n una malla polyhedral con 22-11-07-1111. 3D Polylla Face, dado un cara incidente a una 22-06-01-0011. Terminal-face regions, se debe generar un [[Polyhedron]] usando las [[Frontier-face]] como borde. Los polyhedros deben tener orientaci\u00f3n 22-06-01-0011. Orientation of simpleces</p> <p>A\u00fan no se tiene un m\u00e9todo para generarlo  22-06-03-1159. 3D Travel Phase using DFS </p>"},{"location":"00%20Zettlers/22-06-01-0011.%203D%20travel%20phase/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-01-0011.%20Orientation%20of%20simpleces/","title":"Orientation of simpleces","text":"<p>Creation::  Wednesday 01 of June, 2022.  11:40 PM date:: 22-06-01 UID:: 220601230673 Tags:: [[22-04-14-0011. Mesh generation]] [[Computational geometry]]</p> <p>La orientacion para un [[Polygon]] es el area positiva, es decir, vertices en counter-clock wise</p> <p>La orientacion para un [[Polyhedron]] es el volumen positivo, es decir, [[right-hand rule]]</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Orientation%20of%20simpleces/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-01-0011.%20Orientation%20of%20simpleces/#order-of-vertices-orientation","title":"Order of vertices: orientation","text":"<p>Any permutation of vertices of an element will represent the same abstract simplex. By convention, the vertices of a simplex is ordered such that the signed volume is positive. Therefore in 2-D, three vertices of a triangle is ordered counterclockwise and in 3-D, the ordering of vertices follows the right-hand rule. The function fixorientation will compute the signed area or volume and permute vertices if necessary.</p> <p>Basic Data Structure Representing a Mesh</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Pymesh/","title":"Pymesh","text":"<p>Creation::  Wednesday 01 of June, 2022.  10:34 AM date:: 22-06-01 UID:: 220601100667 Tags:: [[Python]] [[22-04-14-0011. Mesh generation]]</p> <p>Librer\u00eda de python para generar [[Polyhedral mesh]] y [[Polygon mesh]], encapsula funciones de 22-05-31-0011. TetGen y [[Triangle - Shewchuk]] entre otros. </p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Pymesh/#generacion-de-la-malla-inicial","title":"Generaci\u00f3n de la malla inicial","text":"<p>Se tienen varias figuras iniciales para generar la malla inicial. Revisar en 1</p> <p>Para generar una caja </p> <pre><code>input_mesh = pymesh.generate_box_mesh([0.0, 0.0, 0.0], [1.0, 1.0, 1.0], using_simplex=True)\n</code></pre> <p>Para generar un [[icosphere]] (un [[Platonic solids]])</p> <p>input_mesh = pymesh.generate_icosphere(1.0, [0.0, 0.0, 0.0]);</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Pymesh/#mesh-data-structure","title":"Mesh data structure","text":"<p>Los m\u00e9todos y atributos de mesh data structure son las siguientes, revisar completo en 2</p> <pre><code>mesh.add_attribute(                 mesh.is_edge_manifold(\nmesh.attribute_names                mesh.is_manifold(\nmesh.bbox                           mesh.is_oriented(\nmesh.boundary_edges                 mesh.is_vertex_manifold(\nmesh.boundary_loops                 mesh.nodes\nmesh.boundary_vertices              mesh.nodes_per_element\nmesh.dim                            mesh.num_boundary_edges\nmesh.element_volumes                mesh.num_boundary_loops\nmesh.elements                       mesh.num_components\nmesh.enable_connectivity(           mesh.num_duplicated_faces\nmesh.euler_characteristic           mesh.num_elements\nmesh.faces                          mesh.num_faces\nmesh.genus                          mesh.num_isolated_vertices\nmesh.get_attribute(                 mesh.num_nodes\nmesh.get_attribute_names(           mesh.num_surface_components\nmesh.get_face_adjacent_faces(       mesh.num_vertices\nmesh.get_face_adjacent_voxels(      mesh.num_volume_components\nmesh.get_face_attribute(            mesh.num_voxels\nmesh.get_vertex_adjacent_faces(     mesh.raw_mesh\nmesh.get_vertex_adjacent_vertices(  mesh.remove_attribute(\nmesh.get_vertex_adjacent_voxels(    mesh.set_attribute(\nmesh.get_vertex_attribute(          mesh.vertex_per_face\nmesh.get_voxel_adjacent_faces(      mesh.vertex_per_voxel\nmesh.get_voxel_adjacent_voxels(     mesh.vertices\nmesh.get_voxel_attribute(           mesh.volume\nmesh.has_attribute(                 mesh.voxels\nmesh.is_closed(\n</code></pre> <p>En el caso de mallas 3d, voxels se refiere a los tetrahedros.</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Pymesh/#tetrahedrization","title":"Tetrahedrization","text":"<p>Revisar como generar esto en 3, se puede generar con cgal o tetgen, las otros no funcionan</p> <p>De usar 22-05-31-0011. TetGen para generar las mallas, no se pueden 22-05-31-0011. TetGen#Imprimir aristas y caras interiores como en tetgen con el comando -f. Pareciera que el comando flags permite enviar las flags a tetgen, pero no funciona al menos en la versi\u00f3n probada. Los atributos y m\u00e9todos de la clase tetgen</p> <pre><code>tetgen.coarsening              tetgen.point_markers\ntetgen.coplanar_tolerance      tetgen.point_weights\ntetgen.exact_arithmetic        tetgen.points\ntetgen.faces                   tetgen.regions\ntetgen.flags                   tetgen.run(\ntetgen.keep_convex_hull        tetgen.split_boundary\ntetgen.max_num_steiner_points  tetgen.tetrahedra\ntetgen.max_radius_edge_ratio   tetgen.triangle_markers\ntetgen.max_tet_volume          tetgen.triangles\ntetgen.merge_coplanar          tetgen.verbosity\ntetgen.mesh                    tetgen.vertices\ntetgen.min_dihedral_angle      tetgen.voxels\ntetgen.optimization_level      tetgen.weighted_delaunay\n</code></pre> <p>tetgen.mesh entrega un mesh datastructure</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Pymesh/#diferencias-cgal-y-tetgen-en-pymesh","title":"Diferencias cgal y tetgen en pymesh","text":"<p>[[icosphere]] generado con tetgen </p> <pre><code>input_mesh = pymesh.generate_icosphere(1.0, [0.0, 0.0, 0.0]);\ntetgen = pymesh.tetgen();\ntetgen.points = input_mesh.vertices; # Input points.\ntetgen.triangles = input_mesh.faces; # Input triangles\ntetgen.max_tet_volume = 0.01;\ntetgen.verbosity = 3;\ntetgen.run(); # Execute tetgen\nmesh = tetgen.mesh; # Extract output tetrahedral mesh.\npymesh.save_mesh(\"icosphere_save.off\", mesh)\n</code></pre> <p>![[Pasted image 20220601105252.png]]</p> <p>Generado con cgal</p> <pre><code>input_mesh = pymesh.generate_icosphere(1.0, [0.0, 0.0, 0.0]);\nmesh = pymesh.tetrahedralize(input_mesh, 0.8, engine='cgal')\npymesh.save_mesh(\"icosphere_save.off\", mesh)\n</code></pre> <p>![[Pasted image 20220601105722.png]]</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20Pymesh/#references","title":"References","text":"<ol> <li> <p>Procedural Mesh Generation \u2014 PyMesh 0.2.1 documentation \u21a9</p> </li> <li> <p>Mesh Data Structure \u2014 PyMesh 0.2.1 documentation \u21a9</p> </li> <li> <p>Mesh Generation \u2014 PyMesh 0.2.1 documentation \u21a9</p> </li> </ol>"},{"location":"00%20Zettlers/22-06-01-0011.%20Terminal-face%20regions/","title":"Terminal-face regions","text":"<p>Creation::  Wednesday 01 of June, 2022.  08:31 PM date:: 22-06-01 UID:: 220601200601 Tags:: 22-04-31-0011. (LFPP) Longest-face progragation path 3D</p> <p>Extrapolaci\u00f3n de una [[terminal-edge region]]. Dado una [[Terminal-face]] f, adyacentes a dos [[tetrahedron]] \\(t_1\\) y \\(t_2\\),  la terminal-face region son todos los tetrahedros de los LFPP que contienen a esa teminal-face.</p> <p>Queda demostrar las siguientes preguntas:</p> <ul> <li>[[Demostration terminal-face regions are unique]]</li> <li>[[Demostration  terminal-face region does not overlap]]</li> <li>[[Demostration terminal-face region uses alll initital vertices]]</li> </ul>"},{"location":"00%20Zettlers/22-06-01-0011.%20Terminal-face%20regions/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-01-0011.%20face%20file/","title":"face file","text":"<p>Creation::  Wednesday 01 of June, 2022.  12:26 PM date:: 22-06-01 UID:: 220601120665 Tags:: 22-05-31-0011. TetGen [[Triangle - Shewchuk]]</p> <p>Archivos de caras de una malla, se usa para representar una [[Tetrahedralization]] en Tetgen o una 22-06-06-1806. Triangulation en [[Triangle - Shewchuk]].</p>"},{"location":"00%20Zettlers/22-06-01-0011.%20face%20file/#22-05-31-0011-tetgen","title":"22-05-31-0011. TetGen","text":"<p>En el caso de tetgen el formato es el siguiente</p> <pre><code>A .face file contains a list of triangular faces of the tetrahedralization.\nFirst line: &lt;# of faces&gt; &lt;boundary marker (0 or 1)&gt;\nRemaining lines list # of faces:\n&lt;face #&gt; &lt;node&gt; &lt;node&gt; &lt;node&gt; ... [boundary marker] ... ...\n</code></pre> <p>Si se se usa el comando -f imprime las caras interiores 22-05-31-0011. TetGen#Imprimir aristas y caras interiores</p> <p>Si se usa el comando -nn muestra las caras interiores, despu\u00e9s del boundary marker, un ejemplo de -nnf es:</p> <p>Despu\u00e9s del bpundary marker, tiene los ind de los tetrahedrons vecinos</p> <pre><code>1096  1\n    0      0    85    67  0        0    244\n    1      0    72    85  0        0    245\n    2     67    72     0  0        0    251\n    3     67    85    72  0        0     60\n    4     51    61    97  0        1    120\n    ...\n</code></pre>"},{"location":"00%20Zettlers/22-06-01-0011.%20face%20file/#references","title":"References","text":"<p>[[Tetgen manual 2020]]</p> <p>TetGen default only outputs the boundary faces or the convex hull faces into a .face file. If the -f switch is used, TetGen outputs all faces (including interior faces) of the tetrahedralization. In this case, each interior face will always have a \u20180\u2019 as its boundary marker. This file can be omitted by using the -F switch.</p> <p>The -f switch outputs all triangular faces (including interior faces) of the mesh into a .face file.  Without -f, only the boundary faces or the convex hull faces are output. In the .face file, interior faces and boundary (or convex hull) faces are distinguished by their boundary markers. Each interior face has a boundary marker \u20180\u2019. A non-zero boundary marker means a boundary or convex hull face.</p> <p>If the -nn switch is used, each face contains two additional indices (after the boundary marker) in the corresponding .ele file. They are indices of the tetrahedra containing this face. A \u22121 indicates that there is no adjacent tetrahedron at this side, i.e., it is \u201couter space\u201d.</p>"},{"location":"00%20Zettlers/22-06-02-0011.%203D%20Polylla%20Face%20time%20complexity/","title":"3D Polylla time complexity","text":"<p>Creation::  Thursday 02 of June, 2022.  05:46 PM date:: 22-06-02 UID:: 220602170612 Tags::  22-11-07-1111. 3D Polylla Face</p> <p>El tiempo de generaci\u00f3n de 22-11-07-1111. 3D Polylla Face puede ser lineal con respecto al tama\u00f1o de vertices.</p> <p>Dado una [[Tetrahedral mesh]] T = G(E, V, F) con una estructura basada en caras:</p> <ol> <li>22-06-07-1706. 3D Label phase: Se hace una iteraci\u00f3n en cada cara, O(|V|)</li> <li>22-06-01-0011. 3D travel phase: Si se usa un 22-06-02-0011. Depth-first search (DFS), el costo es O(|V|)</li> <li>22-06-15-1106. 3D repair phase Polylla Face: Se calcula valencia de un [[Barrier-face tip]] y se etiqueta la arista de al medio y se repite la travel phase, al igual que [[Travel phase]], su tiempo O(|V|)</li> </ol>"},{"location":"00%20Zettlers/22-06-02-0011.%203D%20Polylla%20Face%20time%20complexity/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-02-0011.%20Depth-first%20search%20%28DFS%29/","title":"Depth-first search","text":"<p>Creation::  Thursday 02 of June, 2022.  11:19 AM date:: 22-06-02 UID:: 220602110645 Tags:: [[Classic algorithms]]</p> <p>Algoritmo para viajar dentro de un grafo. Se puede hacer recursiva usando la pila del sistema o secuencial, programando uno mismo la pila. Su tiempo es O(|V| + |E|) para viajes sin reperici\u00f3n en un grafo 2D.</p>"},{"location":"00%20Zettlers/22-06-02-0011.%20Depth-first%20search%20%28DFS%29/#version-recursiva","title":"Versi\u00f3n recursiva","text":"<pre><code>procedure DFS(G, v) is\n    label v as discovered\n    for all directed edges from v to w that are in G.adjacentEdges(v) do\n        if vertex w is not labeled as discovered then\n            recursively call DFS(G, w)\n</code></pre>"},{"location":"00%20Zettlers/22-06-02-0011.%20Depth-first%20search%20%28DFS%29/#version-secuencial","title":"Versi\u00f3n secuencial","text":"<pre><code>procedure DFS_iterative(G, v) is\n    let S be a stack\n    S.push(iterator of G.adjacentEdges(v))\n    while S is not empty do\n        if S.peek().hasNext() then\n            w = S.peek().next()\n            if w is not labeled as discovered then\n                label w as discovered\n                S.push(iterator of G.adjacentEdges(w))\n        else\n            S.pop()\n</code></pre>"},{"location":"00%20Zettlers/22-06-02-0011.%20Depth-first%20search%20%28DFS%29/#references","title":"References","text":"<p>Depth-first search - Wikipedia</p>"},{"location":"00%20Zettlers/22-06-02-0011.%20Terminal-faces%20and%20terminal-face%20regions%20exists/","title":"Terminal-faces and terminal-face regions exists","text":"<p>Creation::  Thursday 02 of June, 2022.  06:56 AM date:: 22-06-02 UID:: 220602060698 Tags:: 22-04-16-0011. The terminal-face should exist</p> <p>Se testeo un script de python y genera polygonos que se se ovearlap entre ellos, falta encapsular una terminal-face region como uno solo nomas.</p>"},{"location":"00%20Zettlers/22-06-02-0011.%20Terminal-faces%20and%20terminal-face%20regions%20exists/#terminal-faces-example","title":"Terminal-faces example","text":"<p>Las terminal faces parecen estar uniformemente distribuidas dentro de una malla de volumen. En esta no se consideran las terminal-boder face</p> <p>![[3D_100.1_terminal.off]] ![[Pasted image 20220602070158.png]]</p> <p>Aqu\u00ed considerendo las terminal-borde face</p> <p>![[3D_100.1_terminal 1.off]]</p> <p>![[Pasted image 20220602111636.png]]</p>"},{"location":"00%20Zettlers/22-06-02-0011.%20Terminal-faces%20and%20terminal-face%20regions%20exists/#terminal-face-regions-example","title":"Terminal-face regions example","text":"<p>Aqu\u00ed se muestran los frontier-faces. [[Polyhedral mesh]] with out borders (para ver el interior) ![[3D_100.1_frontier.off]] ![[Pasted image 20220602065650.png]]</p> <p>Y aqu\u00ed sin quitar el borde</p> <p>![[3D_100.1_frontier 1.off]]</p> <p>![[Pasted image 20220602070346.png]]</p>"},{"location":"00%20Zettlers/22-06-02-0011.%20Terminal-faces%20and%20terminal-face%20regions%20exists/#terminal-face-region-converted-to-polyhedron","title":"Terminal-face region converted to polyhedron","text":"<p>Polygono generado con la cara 1 y con la 19 (son la misma creo)</p> <p>![[3D_100.1_poly.off]] ![[Pasted image 20220602133209.png]]</p>"},{"location":"00%20Zettlers/22-06-02-0011.%20Terminal-faces%20and%20terminal-face%20regions%20exists/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-03-1159.%203D%20Travel%20Phase%20using%20DFS/","title":"(1a) 3D Travel Phase","text":"<p>Creation::  Friday 03 of June, 2022.  11:59 AM date:: 22-06-03 UID:: 220603110625 Tags:: 22-06-01-0011. 3D travel phase</p> <p>Se puede generar la travel phase usando 22-06-02-0011. Depth-first search (DFS), despu\u00e9s de etiquetar las caras en la 22-06-07-1706. 3D Label phase. Un ejemplo de ello escrito en python es</p> <pre><code>def DepthFirstSearch(polyhedron, visited_tetra, tetra, frontier_faces, mesh):\n    visited_tetra[tetra.i] = True\n    for i in range(0, 4):\n        face_id = tetra.faces[i]\n        if face_id != -1:\n            if frontier_faces[face_id] == True:\n                fa = mesh.face_list[face_id]\n                polyhedron.append(fa)\n            else:\n                next_tetra = mesh.tetra_list[tetra.neighs[i]]\n                if(visited_tetra[next_tetra.i] == False):\n                    DepthFirstSearch(polyhedron, visited_tetra, next_tetra, frontier_faces, mesh)\n</code></pre> <p>La funci\u00f3n se llama como</p> <pre><code># Genera un pol\u00edgono con las frontier-faces como caras y la terminal_face como generador de la cara\ndef generate_polyhedra_from_terminal_face(terminal_face, bitvector_frontier_edges, mesh):\n\n    visited_tetra = [False] * mesh.n_tetrahedrons\n    terminal_tetra = mesh.tetra_list[mesh.face_list[terminal_face.i].n1 if mesh.face_list[terminal_face.i].n1 != -1 else mesh.face_list[terminal_face.i].n2]\n    print(terminal_tetra.faces)\n    polyhedron = []\n    DepthFirstSearch(polyhedron, visited_tetra, terminal_tetra, bitvector_frontier_edges, mesh)\n\n    print(\"polyhedron: \", len(polyhedron))\n    return polyhedron\n</code></pre>"},{"location":"00%20Zettlers/22-06-03-1159.%203D%20Travel%20Phase%20using%20DFS/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-06-1806.%20Triangulation/","title":"Triangulation","text":"<p>UID:: 220606180656 Date:: 22-06-06 Creation:: Monday 06 of June, 2022.  06:03 PM Tags:: </p> <p>Una triangulaci\u00f3n es una descomposici\u00f3n de un conjunto de puntos \\(V \\in R^d\\) en triangulos. Formalmente se define como:</p> <p>Given a poinset \\(V \\in R^d\\), a triangulation is a d-dimensional [[22-06-06-1806. Simplicial complex]] \\(S\\) whose vertex set is a subset of or equal to \\(V\\). </p> <p>Dado un mismo conjunto de puntos, hay varias triangulaciones de este, la triangulaci\u00f3n que m\u00e1ximiza el area de cada triangulo es la [[Delaunay triangulation]]</p>"},{"location":"00%20Zettlers/22-06-06-1806.%20Triangulation/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-07-1706.%203D%20Label%20phase/","title":"3D Label phase","text":"<p>UID:: 220607170693 Date:: 22-06-07 Creation:: Tuesday 07 of June, 2022.  05:39 PM Tags:: 22-11-07-1111. 3D Polylla Face</p>"},{"location":"00%20Zettlers/22-06-07-1706.%203D%20Label%20phase/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-07-1706.%20GPU%20Label%20phase/","title":"GPU Label phase","text":"<p>UID:: 220607170625 Date:: 22-06-07 Creation:: Tuesday 07 of June, 2022.  05:41 PM Tags:: GPolylla (GPU polylla)</p> <p>Etiquetado de aristas, dado una 22-06-06-1806. Triangulation inicial \\(\\tau = G(E,V,F)\\), se etiqueta cada arista \\(e \\in E\\) usando 4 kernels</p> <ul> <li>22-06-07-1706. Kernel label max edge</li> </ul>"},{"location":"00%20Zettlers/22-06-07-1706.%20GPU%20Label%20phase/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-07-1706.%20Kernel%20label%20max%20edge/","title":"Kernel label max edge","text":"<p>UID:: 220607170617 Date:: 22-06-07 Creation:: Tuesday 07 of June, 2022.  05:43 PM Tags:: GPolylla (GPU polylla) 22-06-07-1706. GPU Label phase</p> <p>Eiquetado de la arista m\u00e1xima. Dado una 22-06-06-1806. Triangulation \\(\\tau = G(E,V,F)\\), representada como [[Half-edge]], se le aplica el siguiente kernel</p> <pre><code>Kernel label_max_edge\nForeach halfedge e in \\tau:\n    curr = e\n    next = e.next\n    prev = e.prev\n    max = max_edge(prev, curr, prev)\n    max_edge[e.face] = max\n</code></pre> <p>max_edge retorna un entero, indicando con 0, 1 o 2 el orden de la arista m\u00e1xima de una cara e.face. Luego se hace la misma comparaci\u00f3n que en [[Label phase]] secuencial de Polylla secuencial</p> <p>Este kernel se repite varias veces, la idea del kernel es que cada arista de una cara compare en el mismo orden al resto de las aristas, as\u00ed cada arista devuelve siempre el mismo max edge de una cara. </p> <p>Se hace de esta manera para que as\u00ed toda la label phase de pueda lanzar en un \u00fanico kernel donde cada hilo est\u00e1 asociado a una \u00fanica arista</p>"},{"location":"00%20Zettlers/22-06-07-1706.%20Kernel%20label%20max%20edge/#references","title":"References","text":"<ul> <li>Mi poto</li> </ul>"},{"location":"00%20Zettlers/22-06-08-1606.%20Kernel%20label%20max%20edge/","title":"Kernel label max edge","text":"<p>UID:: 220608160645 Date:: 22-06-08 Creation::  Wednesday 08 of June, 2022.  04:47 PM Tags:: 22-06-07-1706. Kernel label max edge GPolylla (GPU polylla) </p> <p>Se puede modificar el kernel mostrado en 22-06-07-1706. Kernel label max edge. En vez de que retorne un  0, 1, 2, que marque en el bitvector si un halfedge es el m\u00e1s largo o no.</p> <p>Este kernel entrega como input una lista de halfedges y como output un bitvector max_edge, donde se marca con un 1 si el half-edge \\(e\\) es el m\u00e1s largo.</p> <p>Para ello se compara e.next, e y e.prev, y el indice que sea m\u00e1s largo se marca como \\(1\\) en max_edge</p> <pre><code>Kernel label_max_edge(half-edges, max_edge)\nForeach halfedge e in \\tau:\n    curr = e\n    next = e.next\n    prev = e.next\n    ind_max = max(prev, curr, prev)\n    max_edge[ind_max] = True\n</code></pre>"},{"location":"00%20Zettlers/22-06-08-1606.%20Kernel%20label%20max%20edge/#references","title":"References","text":"<p>![[Recording 20220608182311.webm]]</p>"},{"location":"00%20Zettlers/22-06-09-2306.%20Polliya%20can%20be%20expanden%20to%20higher%20dimension/","title":"Polylla can be expanden to higher dimension","text":"<p>UID:: {{date:YYMMDDHHMMSS}} Date:: {{date:YY-MM-DD}} Creation:: {{date: dddd DD of MMMM, Y.  hh:mm A}} Tags:: Polylla</p> <p>Polylla can be expanden to higher dimensiones. There is a Patter</p> <ul> <li>2d: en tri\u00e1ngulos se usan las aristas para unir, los [[Barrier-edge tips]] son vertices</li> <li>3d: las caras para unir, los [[Barrier-face tip]] son aristas</li> </ul> <p>Creo que polylla puede ser llevado a cualquier dimensi\u00f3n, la \u00fanica condici\u00f3n es que, dado un n-simplex el [[j[[22-07-07-1707. Joining criteria method]] ]] sea unir por el (n-1)-Simplex</p>"},{"location":"00%20Zettlers/22-06-09-2306.%20Polliya%20can%20be%20expanden%20to%20higher%20dimension/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-13-1506.%203D%20Polylla%20python%20prototype/","title":"3D Polylla python prototype","text":"<p>UID:: 220613150643 Date:: 22-06-13 Creation:: Monday 13 of June, 2022.  03:47 PM Tags:: </p> <p>Prototipo hecho en python de 22-11-07-1111. 3D Polylla Face.</p>"},{"location":"00%20Zettlers/22-06-13-1506.%203D%20Polylla%20python%20prototype/#generar-input-con-tetgen","title":"Generar input con tetgen","text":"<p>Para generar el input se usa 22-05-31-0011. TetGen, usar la \u00faltima versi\u00f3n que sino falla.</p> <pre><code>./tetgenex -fznn [archivo .off, ply, node, etc.]\n</code></pre> <p>El -f hace que imprima las caras interiores, el -z que los indices parten por 0 y el -nn hace que cada imprima sus tetrahedrons vecinos</p> <p>Si es una superficie abierta, se debe agregar el comando -c para generar el convex hull. Si es cerrada con -p se mantiene la superficie.</p> <p>Para ejemplos del output ver 22-06-02-0011. Terminal-faces and terminal-face regions exists</p>"},{"location":"00%20Zettlers/22-06-13-1506.%203D%20Polylla%20python%20prototype/#a-destacar","title":"A destacar","text":"<ul> <li>Puede que los boundary marker de 22-06-01-0011. face file tengan adj -1, en ese caso se acepta como boundary marker si es que distinto a 0. (boundary_marker == 1 or == -1)</li> <li>Solo imprime caras por ahora.</li> </ul>"},{"location":"00%20Zettlers/22-06-13-1506.%203D%20Polylla%20python%20prototype/#estructura","title":"Estructura","text":"<p>Su estructura de datos es 22-10-06-1610. Volume mesh data struct</p> <p>Se tienen 3 clases, un vertex, un face y un tedrehedron, que se leen del archivo .node, .face y .ele. Cada clase solo tiene los indices de los elementos</p> <p>El constructor construct_tetrahedral_mesh lee los 3 y genera la listas node_list, face_list, tetra_list que tienen la informaci\u00f3n de malla. </p> <p>Notar cuando se crea tetra_list no tiene la lista del indice de las caras que lo forman, por lo que se hace un ciclo que recorre las caras, ve los tetrahedros que contienen esa cara (los dos indices despu\u00e9s del bondary marker en 22-06-01-0011. face file) y se guardan en esos tetrahedros que se accedieron, los indices que las caras que lo forman. Posible bug, esto no agrega el -1 si un tetrahedro es vecino con la cara exterior, por lo que se pueden tener tetrahedros con solo 3 caras o menos</p> <p>Despu\u00e9s se calcula vencidad, por cada tedrahedro \\(i\\), se ven los vecinos de sus caras y se guarda el vecino \\(j\\) tal que \\(i != j\\). </p>"},{"location":"00%20Zettlers/22-06-13-1506.%203D%20Polylla%20python%20prototype/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-13-2006.%20Join%20triangles%20by%20the%20max%20angle/","title":"Join triangles by the max angle","text":"<p>UID:: 220613200665 Date:: 22-06-13 Creation::  Monday 13 of June, 2022.  08:02 PM Tags:: </p> <p>Se puede cambiar el 22-07-07-1707. Joining criteria method para unit tri\u00e1ngulos por uno que use el area m\u00e1xima de un triangulo en Polylla y 22-11-07-1111. 3D Polylla Face.</p> <ul> <li>En 2d: Unir por arista opuesta al angulo m\u00e1s grande</li> <li>En 3D: Unir por la cara opuesta al angulo m\u00e1s grande</li> </ul> <p>Esto deber\u00eda generar una malla polygonal, ya que estoy completamente segudo que la raz\u00f3n de porqu\u00e9 polylla funciona es porque si se une cada triangulo/tetrahedro por su [[facet]], mientras este sea \u00fanico y cada uno se una de uno a la vez, va a generar polygonos/polyhedros disjuntos entre s\u00ed. Permitiendo usarlos para generar mallas.</p>"},{"location":"00%20Zettlers/22-06-13-2006.%20Join%20triangles%20by%20the%20max%20angle/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-14-1706.%2022-06-14-1706.%20Formato%20output%20Polylla%203D/","title":"22-06-14-1706. Formato output Polylla 3D","text":"<p>UID:: 220614170643 Date:: 22-06-14 Creation:: Tuesday 14 of June, 2022.  05:12 PM Tags:: </p> <p>El siguiente formato se discuti\u00f3 con [[Alejandro Ortiz-Bernardin]] el 14 de junio a las 5 para 22-11-07-1111. 3D Polylla Face, parece que [[VEM 3D matlab]] a\u00fan no estaba desarrollado para esta fecha. Alejandro pidio entregar un cubo unitario hecho en este formato, adem\u00e1s de hacer [[22-06-14-1706. Guitarra Alejandro]] en Polylla</p> <p>El formato es similar al de 2d</p> <pre><code>NOTA: las variables entre [] y los comentarios en #\n\n#Tipo  \nCuboide # puede cambiar  \n#Vertices  \n[Num nodes]  \n[x] [y] [z] # Coordenadas 3d v\u00e9rtices  \n# Caras de la malla, la normal siempre tiene que apuntar hacia afuera del elemento  \n[num polygonos] [Cant v\u00e9rtices\u00a0 que lo forman]  \n# Polyhedros formados como caras  \n[num caras] [ind caras]  \n# Indices las caras que forman las superficie  \n... # A\u00fan no se tiene, Aqu\u00ed se debe en dividir 6 subsecciones y cada uno debe tener la superficie del cubo unitario,  \n# Indices de los v\u00e9rtices borde en la superficie  \n... # A\u00fan no se tiene, Aqu\u00ed se debe en dividir 6 subsecciones y cada uno debe tener la superficie del cubo unitario\n</code></pre> <p>En el caso de los bordes, falta m\u00e1s investigaci\u00f3n de como tenerlo, pero lo que si, deben tener un orden a la hora de entregarlos, se propone mostrar cada cara del cubo unitario de una forma particular, se propone el [[right-hand rule]]</p>"},{"location":"00%20Zettlers/22-06-14-1706.%2022-06-14-1706.%20Formato%20output%20Polylla%203D/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-15-1106.%203D%20repair%20phase%20Polylla%20Face/","title":"3D repair phase","text":"<p>UID:: 220615110694 Date:: 22-06-15 Creation:: Wednesday 15 of June, 2022.  11:38 AM Tags:: </p> <p>Similar a la [[Repair phase]] en Polylla, calcula la valencia de una [[Barrier-face tip]] y elige la [[middle-face]], para convertir un [[interior-face]] en [[Frontier-face]]</p> <p>Uno de los problemas a solucionar es 22-10-06-1610. How find barrier-face tip</p> <p>Para acelerar el proceso, se puede agregar a la 22-06-13-1506. 3D Polylla python prototype una clase que se sea de aristas, y que contenga una lista con todos los tetrahedros y caras adjacentes a esa arista. Teniendo esa estructura el pseud\u1e55cidgo quedar\u00eda as\u00ed</p> <pre><code>Given a barrier-face tip e do:\n    Calculate valence e\n    Calculate mid-face f incident to e\n    label f as frontier-edce\n    negh1, neigh2 = adjacents tetrahedrons to f\n    repeat travel phase for neigh1 y neight 2\n</code></pre> <p>Adem\u00e1s, hay que cambiar la estructura de caras, para que tenga marcado que cara es frontier face y cu\u00e1l no.</p>"},{"location":"00%20Zettlers/22-06-15-1106.%203D%20repair%20phase%20Polylla%20Face/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-15-1806.%20Direct%20methods/","title":"Direct methods","text":"<p>UID:: 220615180621 Date:: 22-06-15 Creation:: Wednesday 15 of June, 2022.  06:52 PM Tags:: </p> <p>Este m\u00e9todo consiste en calcular directamente la wea, se hace de dos maneras</p> <ul> <li>Force method (Flexibility): Usa las fuerzas internas como las inc\u00f3gnitas del problema</li> <li>Displacement method (Stiffness): Usa los displacement de los nodos como las inc\u00f3gnitas del problema.  The governing equations son expresadas en t\u00e9rminos del desplazamiento de los nodos usando ecuaciones de equilibrios y se le aplica la ley relating forces a los desplazamientos</li> </ul> <p>El displacement method es m\u00e1s deseada ya que su formulaci\u00f3n es m\u00e1s simple para la mayor\u00eda de los [[Structural stress-analysis problem]].  Y adem\u00e1s est\u00e1 incorporado en la mayor\u00eda de los software del [[Finite Element Method (FEM)]].</p>"},{"location":"00%20Zettlers/22-06-15-1806.%20Direct%20methods/#references","title":"References","text":"<p>[[@loganFirstCourseFinite2016]]</p>"},{"location":"00%20Zettlers/22-06-16-1706.%20Struct%20of%20edges%20in%20tetrehedron%20mesh/","title":"Struct of edges in tetrehedron mesh","text":"<p>UID:: 220616170642 Date:: 22-06-16 Creation::  Thursday 16 of June, 2022.  05:32 PM Tags:: </p> <p>Implementaci\u00f3n de la estructura que contiene la informaci\u00f3n de la adjacencia de aristas de una [[Tetrahedral mesh]] en el 22-06-13-1506. 3D Polylla python prototype</p> <p>Conseguir la lista de aristas del archivo 23-04-20-1304. ele file</p> <pre><code>class edges:\n    def __init__(self, index, endpoint1, endpoint2):\n        self.i = index\n        self.e1 = endpoint1\n        self.e2 = endpoint2\n        self.tetraneighs = set([])\n\ndef construct_edge_list:\n    edge_list = self.read_edge_list(edge_file)\n    for each e in edge_list:\n        v1 = e.e1\n        v2 = e.e2\n        for each f in face_list:\n            if (v1 - v2) est\u00e1 dentro de  (f.v1, f.v2, f.v3)\n                neigh_tetra_1 = f.n1\n                neigh_tetra_2 = f.n2\n        e.tetraneights.add(neigh_tetra_1, neigh_tetra_2)    \n</code></pre>"},{"location":"00%20Zettlers/22-06-16-1706.%20Struct%20of%20edges%20in%20tetrehedron%20mesh/#a-considerar","title":"A considerar","text":"<ul> <li>A futuro, hay que agregar a la structura face un indice que indice que si ya se uso o no en una terminal-edge region</li> <li>La lista de vecinos est\u00e1 en orden aleatorio en edges</li> <li>el set hace que se eviten repetir los tetrahedros en la lista</li> <li>Buscar una forma de comparar las aristas explicitas en edges con las a aristas implicitas de faces</li> <li>Ver si existe otra forma de generar las adjacencias de las aristas en el manual [[Tetgen manual 2020]]. </li> </ul>"},{"location":"00%20Zettlers/22-06-16-1706.%20Struct%20of%20edges%20in%20tetrehedron%20mesh/#references","title":"References","text":""},{"location":"00%20Zettlers/22-06-17-1906.%20Parallel%20half-edge%20construction/","title":"Parallel half-edge construction","text":"<p>UID:: 220617190607 Date:: 22-06-17 Creation:: Friday 17 of June, 2022.  07:09 PM Tags:: </p> <p>Modificaci\u00f3n de GPolylla (GPU polylla) para acelerar la construcci\u00f3n de la estructura halfedege. Para ello se debe modificar:</p> <ul> <li>En la construcci\u00f3in de exterior-halfedges, se debe usar la [[22-06-11-0206. Euler characteristic]] para calcular la cantidad de half-edges, y as\u00ed evitar tener que agregar half-edges al final de vector de halfedges.</li> <li>En la construcci\u00f3n de interiores se debe hacer un for dentro del for de caras para que viaje por aristas.</li> </ul>"},{"location":"00%20Zettlers/22-06-17-1906.%20Parallel%20half-edge%20construction/#references","title":"References","text":""},{"location":"00%20Zettlers/22-07-01-1807.%20Half-edge%20memory%20cost%20in%20Polylla/","title":"Half-edge memory cost in Polylla","text":"<p>UID:: 220701180776 Date:: 22-07-01 Creation::  Friday 01 of July, 2022.  06:56 PM Tags:: </p> <p>El costo de usar half-edge en Polylla es grande, en especial si se compara con la estrutra de datos usada en 22-07-01-1907. Triangle data structure. Aqu\u00ed una tabla de comparaci\u00f3n del costo de generar una triangulaci\u00f3n en Polylla y en triangle en gb:</p> triangle 1.node 1.ele 1.neigh total Polylla 15 M 20 M 2.7 1.1 1.6 1.6 4.6 8.5 30 M 4.1 1.7 2.4 2.4 6.7 12.2 35 M 4.8 19 2.8 2.8 7.5 Triangulaci\u00f3n 8.5, despu\u00e9s se cae <p>Notar que Polylla usa el doble de memoria, en mantener la triangulaci\u00f3n inicial, y luego la copia para hacer lo siguiente</p> <p>A pesar de ser eficiente la estructura de triangle, el [[Half-edge]] de Polylla tiene la ventaja de que se puede generar mallas superiores a 35 M, que es el l\u00edmite de Polylla. </p>"},{"location":"00%20Zettlers/22-07-01-1807.%20Half-edge%20memory%20cost%20in%20Polylla/#references","title":"References","text":""},{"location":"00%20Zettlers/22-07-01-1907.%20Triangle%20data%20structure/","title":"Triangle data structure","text":"<p>UID:: 220701190704 Date:: 22-07-01 Creation:: Friday 01 of July, 2022.  07:02 PM Tags:: </p> <p>![[Pasted image 20220701190306.png]] Figure 1: A triangulation (top) and its corresponding representations with quad-edge and triangular data structures. Each quad-edge and each triangle contains six pointers.</p> <p>Estructura de datos que usa triangle basada en las caras, est\u00e1 basada en la estructura quad-edge, de otro paper, que esta basada en las aristas. Tiene la ventaja que usa menos emoria que la quad-edge. Pero tiene la restricci\u00f3n que cada arista est\u00e1 representada por dos caras, por lo que las aristas de borde tiene ghost triangles que son utiles para viajar por el convexhull y para hacer el edgeflip.</p> <p>![[Pasted image 20220701190701.png]]</p> <p>En la implementaci\u00f3n usa una estructura llamada [[22-07-01-1907. memorypool]], es media rara la wea.</p>"},{"location":"00%20Zettlers/22-07-01-1907.%20Triangle%20data%20structure/#references","title":"References","text":"<p>[[@shewchukTriangleEngineering2D1996]] Ver online: Triangulation Algorithms and Data Structures</p>"},{"location":"00%20Zettlers/22-07-06-1407.%20Delfin%203D/","title":"Delfin 3D","text":"<p>UID:: 220706140774 Date:: 22-07-06 Creation::  Wednesday 06 of July, 2022.  02:29 PM Tags:: </p> <p>Polylla y 22-10-13-1310. 3D Polylla est\u00e1n basados en este trabajo.</p> <p>Versi\u00f3n 3d de [[Delfin]]. Dado una [[Delaunay tetrahedralization]] G = (V,E,F). El algoritmo ordena todas las aristas de mayor a menor.   Por cada  arista \\(e \\in E\\) crea una lista \\(L\\) con los tetrahedros adjacentes \\(e\\), luego por, cada tetrahedro \\(t \\in L\\), ve su arista \\(e_l\\) m\u00e1s larga, y si est\u00e1 arista est\u00e1 en el borde de \\(L\\), agrega todos los tetrahedros adjacentes a \\(e_l\\) a \\(L\\). Repite este proceso hasta que ya no hayan m\u00e1s tetrahedros que agregar. </p> <p>Nota que en [[3D Longest-edge propagation path (3D Lepp)]] el proceso de lepp termina cuando se alcanza una [[terminal-edge]], pero en este se continua hasta que no hayan m\u00e1s tetrahedros que agregar, por lo que hay que demostrar que este proceso tiene termino y ver si es posible que se agregue la malla entera.</p> <p>Hay dos versiones, la original de Hervias y la de Alsonso, que le agrega el join de vacios. En ambas versiones tetrahedra_set es una cola (pero no lo mencionan), y cada tetrahedro agregado al final de la cola se verifica su longest-edge y el vecino con el que la comportarte, si este vecino es distinto al tetrahedro del que viene, entonces se agrega al final de la cola. Este comportamiento es lo mismo que un DFS, pero no lo pusieron para cagarte la existencia gastando tiempo extra intentando descubrirlo.</p>"},{"location":"00%20Zettlers/22-07-06-1407.%20Delfin%203D/#version-hervias","title":"Versi\u00f3n Hervias","text":"<p>![[Pasted image 20220706151102.png]]</p>"},{"location":"00%20Zettlers/22-07-06-1407.%20Delfin%203D/#version-alonso","title":"Versi\u00f3n Alonso","text":"<p>![[Pasted image 20220706144220.png]]</p>"},{"location":"00%20Zettlers/22-07-06-1407.%20Delfin%203D/#references","title":"References","text":"<p>[[@alonsoDelaunayTessellationBased2016]]</p>"},{"location":"00%20Zettlers/22-07-06-1607.%203D%20Polylla%20edge%20DFS/","title":"3D Polylla edge DFS","text":"<p>UID:: 220706160711 Date:: 22-07-06 Creation:: Wednesday 06 of July, 2022.  04:48 PM Tags:: </p> <p>22-06-02-0011. Depth-first search (DFS) usado por 22-07-06-1607. 3D Polylla Edge. Este DFS toma como input una [[Tetrahedral mesh]] y una arista inicial \\(e\\), y crea una lista de tetrahedros \\(L\\). </p> <p>El algoritmo parte uniendo todos los tetrahedros adjacentes a \\(e_{init}\\) a \\(L\\), luego por cada tetrahedro agregado \\(t\\) con una arista m\u00e1xima \\(e_{max}\\) y una arista de origen \\(e'_{max}\\)  agrega los tetrahedros adjacentes a \\(e_{max}\\), repite este proceso hasta que \\(e'_{max}\\) == \\(e_{max}\\), es decir, hasta que no hayan m\u00e1s tetrahedros que compartan su arista m\u00e1s larga con \\(L\\).</p> <pre><code>DFS(mesh, e, L):\n    for each tetrahedron t adjacent to e\n        if t is not visited\n            L = L + t\n            label t as visited\n            e_max = max edge of T\n            if e != e_max \n                DFS(mesh, e_max, L)\n</code></pre>"},{"location":"00%20Zettlers/22-07-06-1607.%203D%20Polylla%20edge%20DFS/#references","title":"References","text":""},{"location":"00%20Zettlers/22-07-07-1707.%20Join%20criteria%20for%20edges/","title":"Join criteria for edges","text":"<p>UID:: 220707170721 Date:: 22-07-07 Creation:: Thursday 07 of July, 2022.  05:11 PM Tags:: </p> <p>22-07-07-1707. Joining criteria method Criterio para unir aristas en 22-07-06-1607. 3D Polylla Edge. Debido que los polyhedros generados van a depender de que aristas se usen primero para generarlos, hay que seleccionar un orden especifico que diga cuales aristas se van a elegir para generar los polyhedros de la malla. Este criterio debe tener las siguientes caracteriticas:</p> <ol> <li>El criterio debe generar polyhedros que usen todos los tetrahedros de la malla inicial, no pueden elementos de la malla sin usar.</li> <li>El criterio debe evitar se genere el mismo polyhedro dos veces</li> </ol> <p>Para evitar el punto 1, se pueden ordenar la aristas de tal manera que en la lista ordenada esten todas las aristas de la malla inicial e ir borrandolas a medidas que se vayan agregando tetrahedros que la contengan, de est\u00e1 manera usar todas las aristas y tetrahedros van a ser usados.</p> <p>Los criterios que se tienen actualmente son:</p> <ol> <li>Terminal-edges: Se ordenan las aristas de mayor a menor, al hacer eso las primeras aristas que se usen van a ser siempre [[Terminal-edge]] ya que al ser las aristas m\u00e1s largas, tambi\u00e9n son las m\u00e1s largas de los tetrahedros que lo comparten. Con este criterio se usan todas las terminal-edges para generar una malla. Si es que quedaran aristas sin usar a\u00fan en un polyhedro, est\u00e1s van a estar al final de la lista y van a ser usados igual.</li> <li>Aleatorio: Se seleccionan aleatoriamente las aristas a elegir hasta que ya se hayan usado todas las aristas de la malla.</li> </ol>"},{"location":"00%20Zettlers/22-07-07-1707.%20Join%20criteria%20for%20edges/#references","title":"References","text":""},{"location":"00%20Zettlers/22-07-07-1707.%20Joining%20criteria%20method/","title":"Joining criteria method","text":"<p>UID:: 220707170749 Date:: 22-07-07 Creation:: Thursday 07 of July, 2022.  05:34 PM Tags:: </p> <p>Criterio para unir elementos de una [[Polygon mesh]] y [[Polyhedral mesh]]. Los criterios que se tienen actualmente son:</p>"},{"location":"00%20Zettlers/22-07-07-1707.%20Joining%20criteria%20method/#2d-polylla","title":"2D Polylla","text":"<ul> <li>22-06-13-2006. Join triangles by the max angle</li> </ul>"},{"location":"00%20Zettlers/22-07-07-1707.%20Joining%20criteria%20method/#22-07-06-1607-3d-polylla-edge","title":"22-07-06-1607. 3D Polylla Edge","text":"<ul> <li>22-07-07-1707. Join criteria for edges</li> </ul>"},{"location":"00%20Zettlers/22-07-07-1707.%20Joining%20criteria%20method/#22-11-07-1111-3d-polylla-face","title":"22-11-07-1111. 3D Polylla Face","text":"<ul> <li>[[Join tetrahedrons by Max area triangle]]</li> <li>22-10-17-1410. Join tetrahedros face by incircle radious</li> </ul>"},{"location":"00%20Zettlers/22-07-07-1707.%20Joining%20criteria%20method/#ideas","title":"Ideas","text":"<p>No s\u00e9 como implementarlo, pero una alternativa ser\u00eda el [[Dihedral angle]], el problema es que este se refiere al angulo de intersecci\u00f3n entre dos caras, por lo al buscar la cara con el mayor dihedral angulo opuesto solo va a conseguir que dos lados de un triangulo esten m\u00e1s separados, si elige el mayor angulo encontre puede llevar a que se unan los tetrahedros con triangulos muy angostos.</p>"},{"location":"00%20Zettlers/22-07-07-1707.%20Joining%20criteria%20method/#references","title":"References","text":""},{"location":"00%20Zettlers/22-07-07-1707.%20Precalculate%20terminal-element/","title":"Precalculate terminal-element","text":"<p>UID:: 220707170762 Date:: 22-07-07 Creation::  Thursday 07 of July, 2022.  05:36 PM Tags:: </p> <p>En el caso de que las [[terminal-element]] contentan los mismo polygonos en 2d o polyhedrons en 3D, se pueden precalcular los elementos usando un [[label system]]. Los que se saben que se pueden precalcular son:</p> <ol> <li>Polylla: las [[2D terminal-edges are unique]] y se puede hacer una [[Label phase]] genere el l\u00edmite de los [[terminal-edge]], delimitandolos por aristas.</li> <li>22-11-07-1111. 3D Polylla Face: Las [[Demostration terminal-face regions are unique|terminal-face regions are unique]], por lo que se pueden cualquierar las faces con areas m\u00e1s peque\u00f1as para calcular el l\u00edmite de cada 22-06-01-0011. Terminal-face regions</li> </ol> <p>Los que no se pueden precacular son</p> <ol> <li>22-07-06-1607. 3D Polylla Edge: Dependiendo del orden de las aristas que se elijan para generar las [[3D terminal-edge region]] va a cambiar como lo tetrahedrons elegidos para generar cada polyhedro. Esto es debido a que un polyhedro puede pertenecer a m\u00e1s de una terminal-edge region.</li> </ol>"},{"location":"00%20Zettlers/22-07-07-1707.%20Precalculate%20terminal-element/#references","title":"References","text":""},{"location":"00%20Zettlers/22-07-08-1607.%20number%20of%20edges%20Delaunay%20triangulation/","title":"number of edges Delaunay triangulation","text":"<p>UID:: 220708160702 Date:: 22-07-08 Creation::  Friday 08 of July, 2022.  04:55 PM Tags:: </p> <p>By [[22-06-11-0206. Euler characteristic]], the number of edges of a 22-06-06-1806. Triangulation is</p> <p>\\(|E| = 3n - 3 - h\\)</p> <p>The number of triangles is</p> <p>\\(|F| = 2n - 2 - h\\)</p>"},{"location":"00%20Zettlers/22-07-08-1607.%20number%20of%20edges%20Delaunay%20triangulation/#references","title":"References","text":"<p>https://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect12-delaun-prop.pdf</p>"},{"location":"00%20Zettlers/22-07-20-1207.%20Insphere%20function/","title":"Insphere function","text":"<p>UID:: 220720120790 Date:: 22-07-20 Creation::  Wednesday 20 of July, 2022.  12:05 PM Tags:: </p> <p>Funci\u00f3n para calcular si un punto e est\u00e1 dentro de la esfera del tetrahedro (a,b,c,d), es decir, la [[Circumscribed sphere]] del tetrahedro.</p> <p>![[Pasted image 20220720121051.png]]</p>"},{"location":"00%20Zettlers/22-07-20-1207.%20Insphere%20function/#codigo","title":"C\u00f3digo","text":"<p>El c\u00f3digo est\u00e1 ac\u00e1 www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c</p> <pre><code>/*****************************************************************************/\n/*                                                                           */\n/*  inspherefast()   Approximate 3D insphere test.  Nonrobust.               */\n/*  insphereexact()   Exact 3D insphere test.  Robust.                       */\n/*  insphereslow()   Another exact 3D insphere test.  Robust.                */\n/*  insphere()   Adaptive exact 3D insphere test.  Robust.                   */\n/*                                                                           */\n/*               Return a positive value if the point pe lies inside the     */\n/*               sphere passing through pa, pb, pc, and pd; a negative value */\n/*               if it lies outside; and zero if the five points are         */\n/*               cospherical.  The points pa, pb, pc, and pd must be ordered */\n/*               so that they have a positive orientation (as defined by     */\n/*               orient3d()), or the sign of the result will be reversed.    */\n/*                                                                           */\n/*  Only the first and last routine should be used; the middle two are for   */\n/*  timings.                                                                 */\n/*                                                                           */\n/*  The last three use exact arithmetic to ensure a correct answer.  The     */\n/*  result returned is the determinant of a matrix.  In insphere() only,     */\n/*  this determinant is computed adaptively, in the sense that exact         */\n/*  arithmetic is used only to the degree it is needed to ensure that the    */\n/*  returned value has the correct sign.  Hence, insphere() is usually quite */\n/*  fast, but will run more slowly when the input points are cospherical or  */\n/*  nearly so.                                                               */\n/*                                                                           */\n/*****************************************************************************/\n\nREAL inspherefast(pa, pb, pc, pd, pe)\nREAL *pa;\nREAL *pb;\nREAL *pc;\nREAL *pd;\nREAL *pe;\n{\n  REAL aex, bex, cex, dex;\n  REAL aey, bey, cey, dey;\n  REAL aez, bez, cez, dez;\n  REAL alift, blift, clift, dlift;\n  REAL ab, bc, cd, da, ac, bd;\n  REAL abc, bcd, cda, dab;\n\n  aex = pa[0] - pe[0];\n  bex = pb[0] - pe[0];\n  cex = pc[0] - pe[0];\n  dex = pd[0] - pe[0];\n  aey = pa[1] - pe[1];\n  bey = pb[1] - pe[1];\n  cey = pc[1] - pe[1];\n  dey = pd[1] - pe[1];\n  aez = pa[2] - pe[2];\n  bez = pb[2] - pe[2];\n  cez = pc[2] - pe[2];\n  dez = pd[2] - pe[2];\n\n  ab = aex * bey - bex * aey;\n  bc = bex * cey - cex * bey;\n  cd = cex * dey - dex * cey;\n  da = dex * aey - aex * dey;\n\n  ac = aex * cey - cex * aey;\n  bd = bex * dey - dex * bey;\n\n  abc = aez * bc - bez * ac + cez * ab;\n  bcd = bez * cd - cez * bd + dez * bc;\n  cda = cez * da + dez * ac + aez * cd;\n  dab = dez * ab + aez * bd + bez * da;\n\n  alift = aex * aex + aey * aey + aez * aez;\n  blift = bex * bex + bey * bey + bez * bez;\n  clift = cex * cex + cey * cey + cez * cez;\n  dlift = dex * dex + dey * dey + dez * dez;\n\n  return (dlift * abc - clift * dab) + (blift * cda - alift * bcd);\n}\n</code></pre>"},{"location":"00%20Zettlers/22-07-20-1207.%20Insphere%20function/#references","title":"References","text":"<p>[[@richardshewchukAdaptivePrecisionFloatingPoint1997]] P\u00e1gina: Fast Robust Predicates for Computational Geometry C\u00f3digo: www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c</p>"},{"location":"00%20Zettlers/22-08-10-1508.%202D%20Polylla%20travel%20phase%20conecting%20halfedges/","title":"2D Polylla travel phase conecting halfedges","text":"<p>UID:: 220810150839 Date:: 22-08-10 Creation::  Wednesday 10 of August, 2022.  03:51 PM Tags:: </p> <p>Se puede modificar la [[Travel phase]] de Polylla haciendo que cada arista etiquetada como un frontier-edge use la operaci\u00f3n search_frontier_edge para buscar a su siguiente frontier-edge y cambie la operaci\u00f3n next.</p> <p>Esto es util para la versi\u00f3n GPU 22-05-26-0011. GPU parallel Travel phase</p>"},{"location":"00%20Zettlers/22-08-10-1508.%202D%20Polylla%20travel%20phase%20conecting%20halfedges/#references","title":"References","text":""},{"location":"00%20Zettlers/22-08-11-0908.%20Problemas%20conocidos%20Polylla%20Comprimida/","title":"Problemas conocidos Polylla Comprimida","text":"<p>UID:: 220811090831 Date:: 22-08-11 Creation::  Thursday 11 of August, 2022.  09:44 AM Tags:: </p> <p>Errores de Compact Polylla</p>"},{"location":"00%20Zettlers/22-08-11-0908.%20Problemas%20conocidos%20Polylla%20Comprimida/#error-1","title":"Error 1","text":"<p>Con la malla de 10000 elementos hay un elemento sin ver, esto fue generado sin la repair fase</p> <p>![[Pasted image 20220811094504.png]]</p>"},{"location":"00%20Zettlers/22-08-11-0908.%20Problemas%20conocidos%20Polylla%20Comprimida/#error-2","title":"Error 2","text":"<p>cuando genero mallas de 45 millones con cgal, polylla da este error </p> <pre><code>Memory after reset 1305 bytes\n---------------------------------\n---------------------------------\nCompact Triangulation generated in 72406.2 seconds\nMemory used to generate compact mesh 9494548593 bytes\nMemory of compact mesh 819861321 bytes\nMemory of pemb serialize 92851875 bytes\nMemory of nodes of compact mesh 720000000 bytes\n---------------------------------\ncompactPolylla: /home/ssalinas/Compress-Polylla-Mesh/external/sdsl-lite/include/sdsl/select_support_mcl.hpp:349: sdsl::select_support::size_type sdsl::select_support_mcl&lt;t_bit_pattern, t_pattern_len&gt;::select(sdsl::select_support::size_type) const [with unsigned char t_b = 1; unsigned char t_pat_len = 1; sdsl::select_support::size_type = long unsigned int]: Assertion `i &gt; 0 and i &lt;= m_arg_cnt' failed.\n./generateMeshes.sh: line 17: 10266 Aborted                 ./compactPolylla ${meshes_folder}/${node_file} ${meshes_folder}/${ele_file} ${meshes_folder}/${neigh_file} ${folder_output}/${output}\nssalinas@apophis:~/Compress-Polylla-Mesh/experiments$ \n</code></pre>"},{"location":"00%20Zettlers/22-08-11-0908.%20Problemas%20conocidos%20Polylla%20Comprimida/#references","title":"References","text":""},{"location":"00%20Zettlers/22-08-11-1208.%20Pemb%20needs%20be%20inverted%20to%20encapsulate%20it%20to%20a%20halfedge%20data%20structure/","title":"Pemb needs be inverted to encapsulate it to a halfedge data structure","text":"<p>UID:: 220811120822 Date:: 22-08-11 Creation::  Thursday 11 of August, 2022.  12:24 PM Tags:: </p> <p>[[Pemb]] tiene la orientaci\u00f3n de las aristas en [[clockwise]], por lo que se deben cambiar las funciones para hacerlas anticlockwise y poder encapsular pemb como un [[Half-edge]]</p>"},{"location":"00%20Zettlers/22-08-11-1208.%20Pemb%20needs%20be%20inverted%20to%20encapsulate%20it%20to%20a%20halfedge%20data%20structure/#references","title":"References","text":""},{"location":"00%20Zettlers/22-08-11-1508.%20Polylla%20with%20diff%20distance%20functions/","title":"Polylla with diff  distance functions","text":"<p>UID:: 220811150858 Date:: 22-08-11 Creation::  Thursday 11 of August, 2022.  03:44 PM Tags:: </p> <p>Polylla cambia de acuerdo a la distancia que usa, aqu\u00ed una diferencia entre manhattan y euclidiana</p>"},{"location":"00%20Zettlers/22-08-11-1508.%20Polylla%20with%20diff%20distance%20functions/#distance-manhatan","title":"Distance manhatan","text":"<p>return abs(get_PointX(org) - get_PointX(tgt)) + abs(get_PointY(org) - get_PointY(tgt)); ![[Screenshot from 2022-08-11 15-39-23.png]]</p>"},{"location":"00%20Zettlers/22-08-11-1508.%20Polylla%20with%20diff%20distance%20functions/#distancia-euclidiana","title":"Distancia euclidiana","text":"<p>return pow(get_PointX(org) - get_PointX(tgt), 2) + pow(get_PointY(org) - get_PointY(tgt), 2);</p> <p>![[Screenshot from 2022-08-11 15-43-40.png]]</p>"},{"location":"00%20Zettlers/22-08-11-1508.%20Polylla%20with%20diff%20distance%20functions/#references","title":"References","text":""},{"location":"00%20Zettlers/22-08-12-1208.%203D%20uwu%20ejemplo/","title":"3D uwu ejemplo","text":"<p>UID:: 220812120845 Date:: 22-08-12 Creation::  Friday 12 of August, 2022.  12:36 PM Tags:: </p>"},{"location":"00%20Zettlers/22-08-12-1208.%203D%20uwu%20ejemplo/#references","title":"References","text":""},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/","title":"compact polylla memory optimization","text":"<p>UID:: 220819110879 Date:: 22-08-19 Creation:: Friday 19 of August, 2022.  11:37 AM Tags:: </p> <p>Compact Polylla no ten\u00ed ning\u00fan delete, ni el [[Pemb]] usado tampoco, haciendo que la estructura comprimida usara m\u00e1s espacio que el Polylla con [[Half-edge]]  </p> <p>Este es la bitacora de como fue bajando la memoria usada.</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#polylla-aos","title":"Polylla AOS","text":""},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#mem-inicial-con-los-destructores-ya-hechos","title":"Mem inicial con los destructores ya hechos","text":"<p>Printing triangulation in pg file format as points300.1.pg Triangulation generated in 0.382283 seconds Memory used to generate triangulation 119982 bytes Memory of triangulation 63123 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate Polylla 76669 bytes Memory of Polylla 75479 bytes Memory after reset 1099 bytes Graph done</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#despues-de-agregarle-a-los-vectores-face-and-neigh-cuando-se-llaman","title":"Despues de agregarle &amp; a los vectores face and neigh cuando se llaman","text":"<p>Printing triangulation in pg file format as points300.1.pg Triangulation generated in 0.378331 seconds Memory used to generate triangulation 106770 bytes Memory of triangulation 63123 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate Polylla 76669 bytes Memory of Polylla 75479 bytes Memory after reset 1099 bytes</p> <p>La memoria es final es la misma, pero la necesaria para construir baja un 119982 - 106770 = 13212 bytes</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#compact-polylla","title":"Compact Polylla","text":""},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#memoria-inicial-despues-de-generar-polylla","title":"Memoria inicial despu\u00e9s de generar polylla","text":"<p>Memory after reset 1099 bytes</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#versin-inicial","title":"Vers\u00edn inicial","text":"<p>Compact Triangulation generated in 0.90674 seconds Memory used to generate compact mesh 68784 bytes Memory of compact mesh 62759 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 76157 Memory of compact Polylla 75119 bytes malloc_count ### exiting, total: 500.878, peak: 76.157, current: 55.668</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#agregando-el-destructor-y-agregando-delete-a-construct_pemb","title":"Agregando el destructor y agregando delete a construct_pemb","text":"<p>Compact Triangulation generated in 0.677978 seconds Memory used to generate compact mesh 68480 bytes Memory of compact mesh 56775 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 70173 Memory of compact Polylla 69135 bytes malloc_count ### exiting, total: 500.878, peak: 70.173, current: 49.684</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#agregando-destructor-a-la-clase-graph","title":"Agregando destructor a la clase graph","text":"<p>Compact Triangulation generated in 0.664817 seconds Memory used to generate compact mesh 68480 bytes Memory of compact mesh 27191 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 40589 Memory of compact Polylla 39551 bytes malloc_count ### exiting, total: 500.878, peak: 40.589, current: 20.100</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#agregando-destructor-a-tree","title":"Agregando destructor a Tree","text":"<p>Compact Triangulation generated in 0.713711 seconds Memory used to generate compact mesh 68480 bytes Memory of compact mesh 15207 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 28605 Memory of compact Polylla 27567 bytes malloc_count ### exiting, total: 500.878, peak: 28.605, current: 8.116</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#agregando-delete-a-tree_cycle-no-afecta","title":"Agregando delete a tree_cycle (no afecta)","text":"<p>Compact Triangulation generated in 0.673873 seconds Memory used to generate compact mesh 68480 bytes Memory of compact mesh 15207 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 28605 Memory of compact Polylla 27567 bytes malloc_count ### exiting, total: 500.878, peak: 28.605, current: 8.116</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#agregando-delete-a-dos-funciones-en-graphhpp","title":"Agregando delete a dos funciones en graph.hpp","text":"<p>Compact Triangulation generated in 0.857183 seconds Memory used to generate compact mesh 64016 bytes Memory of compact mesh 8115 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 21513 Memory of compact Polylla 20475 bytes malloc_count ### exiting, total: 500.878, peak: 21.513, current: 1.024</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#agregando-delete-al-constructo-de-pemb-en-pembhpp-no-afecta","title":"Agregando delete al constructo de pemb en pemb.hpp (no afecta)","text":"<p>Compact Triangulation generated in 0.689276 seconds Memory used to generate compact mesh 64016 bytes Memory of compact mesh 8115 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 21513 Memory of compact Polylla 20475 bytes malloc_count ### exiting, total: 500.878, peak: 21.513, current: 1.024</p>"},{"location":"00%20Zettlers/22-08-19-1108.%20compact%20polylla%20memory%20optimization/#depues-de-eliminar-los-dos-bitvectores-de-triangulos","title":"depu\u00e9s de eliminar los dos bitvectores de triangulos","text":"<p>Compact Triangulation generated in 0.671505 seconds Memory used to generate compact mesh 63936 bytes Memory of compact mesh 8035 bytes Mesh with 98 polygons 397 edges and 4 barrier-edge tips. Memory used to generate compact Polylla: 21433 Memory of compact Polylla 20395 bytes malloc_count ### exiting, total: 487.586, peak: 21.433, current: 1.024</p>"},{"location":"00%20Zettlers/22-08-22-1608.%20edge%20collapse/","title":"edge collapse","text":"<p>UID:: 220822160801 Date:: 22-08-22 Creation:: Monday 22 of August, 2022.  04:38 PM Tags:: </p> <p>Proceso de mover un vertice y unirlo con otro para as\u00ed eliminar vertices y adjacencias.</p> <p>![[Pasted image 20220822164547.png]]</p>"},{"location":"00%20Zettlers/22-08-22-1608.%20edge%20collapse/#references","title":"References","text":"<p>An example of the edge collapse\u00a0 | Download Scientific Diagram</p>"},{"location":"00%20Zettlers/22-08-23-1608.%20Halfedge%20infographics/","title":"Halfedge infographics","text":"<p>UID:: 220823160830 Date:: 22-08-23 Creation::  Tuesday 23 of August, 2022.  04:54 PM Tags:: [[infographics]] [[Half-edge]]</p> <p>![[Pasted image 20220823165510.png]]</p> <p>![[Pasted image 20220823165519.png]] ![[Pasted image 20220823165529.png]]</p> <p>![[Pasted image 20220823165538.png]]</p>"},{"location":"00%20Zettlers/22-08-23-1608.%20Halfedge%20infographics/#references","title":"References","text":"<p>https://twitter.com/miamiamia0103/status/1495438738398191617</p>"},{"location":"00%20Zettlers/22-09-01-1109.%20Surface%20Polylla%20mesh%20generation/","title":"22 09 01 1109. Surface Polylla mesh generation","text":"<p>f# Surface Polylla mesh generation UID:: 220901110907 Date:: 22-09-01 Creation::  Thursday 01 of September, 2022.  11:56 AM Tags:: </p> <p>Uno de los problemas de usar Polylla para generar soperficies, es que genera poligonos no [[22-06-13-1406. Coplanar]], por lo que hay que buscar una forma de arreglar la infomaci\u00f3n ge\u00f3metrica.</p> <p>Una forma de arreglar esto es promediar la informaci\u00f3n g\u00e9ometrica de los v\u00e9rtices, pero ello cambiar\u00eda la forma de la malla original.</p> <p>Una aplicaci\u00f3n de hacer esto es para generar [[Low-poly mesh]]</p>"},{"location":"00%20Zettlers/22-09-01-1109.%20Surface%20Polylla%20mesh%20generation/#references","title":"References","text":""},{"location":"00%20Zettlers/22-09-06-1709.%20Comparision%20compact%20halfedge%20papers/","title":"Comparision compact halfedge papers","text":"<p>UID:: 220906170902 Date:: 22-09-06 Creation::  Tuesday 06 of September, 2022.  05:30 PM Tags:: </p>"},{"location":"00%20Zettlers/22-09-06-1709.%20Comparision%20compact%20halfedge%20papers/#indicar-si-pemb-permite-stream-construction","title":"Indicar si pemb permite stream construction","text":"<p>## Paper [[@aleardiArraybasedCompactData2018]] Array-based compact data structures for triangulations: Practical solutions with theoretical guarantees</p> <ul> <li>Solo funciona con triangulaciones</li> <li>Construcci\u00f3n via stream</li> <li>succinct representation de un grafo</li> <li>Usa una Schnyder wood graph representation para representar una triangulaci\u00f3n (se puede computar linear)</li> <li>Divide una triangulaci\u00f3n en 3 spanning trees</li> <li>Tiene una tabla con un resumen de los costos de otras estructuras compactas, su estado del arte define la diff entre compression and compactation</li> </ul> <p>## paper [[@alumbaughCompactArrayBasedMesh2005]]  Compact Array-Based Mesh Data Structures</p> <ul> <li>Paper m\u00e1s viejo, dice ser el creador del Half-faces (Doubly linked face list).</li> <li>Para comprimir polygonal meshes, combina la estructura tradicional de half-edge con tablas que contienen la informaci\u00f3n de cara cada.</li> <li>Est\u00e1 estructura le asigna a cada half-edge un id y solo guarda la informaci\u00f3n de los twin half-edges and un mapeo de cada v\u00e9rtice a cualquiera de sus half-edge incidentes.</li> <li>Permite mesh modificaci\u00f3n</li> <li>Su tama\u00f1o es 12n + n</li> <li>Permite compresi\u00f3n y compactation</li> </ul> <p>## Paper [[@damiandStrippedHalfedgeData2021]]  Stripped halfedge data structure for parallel computation of arrangements of segments</p> <ul> <li>Divide un grafo planar en strips, que son lineas verticales que descomponen el plano en intervalos disjuntos. La uni\u00f3n de todos los strips son una partici\u00f3n del plano</li> <li>V\u00e9rtice pertecene a un solo strip, las aristas que pertenecen a m\u00e1s de un strips se les llama critical edge</li> <li>Permite construcci\u00f3n por stream y paralilismo.</li> <li>Cada strips funciona como una data structure \u00fanico, tienen un sistema de etiquetado \u00fanico que se unen a trav\u00e9s de los critical edges.</li> </ul> <p>## Paper [[@danovaroHalfedgeTreeCompact2005]] The half-edge tree: A compact data structure for level-of-detail tetrahedral meshes</p> <ul> <li>Usa la t\u00e9cnica [[half-edge collapse]] para compactar [[Tetrahedral mesh]]</li> </ul>"},{"location":"00%20Zettlers/22-09-06-1709.%20Comparision%20compact%20halfedge%20papers/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-06-1110.%20edge%20file/","title":"edge file","text":"<p>UID:: 221006111037 Date:: 22-10-06 Creation:: Thursday 06 of October, 2022.  11:37 AM Tags:: </p> <p>Edge file de 22-05-31-0011. TetGen, tiene la siguiente informaci\u00f3n si se usa el commando -nne</p> <pre><code>First line: &lt;# of edges&gt; &lt;boundary marker (0 or 1)&gt;\n&lt;index&gt; &lt;v1&gt; &lt;v2&gt; &lt;boundary marker&gt; &lt;tetrahedron&gt; \n</code></pre> <p>Se ven as\u00ed,</p> <pre><code>660  1\n    0     11    92  0  0\n    1     11    85  0  0\n    2      0    85  0  0\n    3      0    92  0  0\n    4      0    11  0  0\n    5     85    92  0  0\n    6     31    34  0  1\n    7     31    72  0  1\n    8     65    72  0  1\n    9     65    34  0  1\n   10     65    31  0  1\n   11     72    34  0  1\n</code></pre> <p>Muestra un tetrahedro por arista, las aristas est\u00e1n ordenadas por el indice de los tetrahedros, al inicio muestra todas las aristas de de un tetrahedro, pero despu\u00e9s solo muestra uno o dos aristas por tetrahedros.</p>"},{"location":"00%20Zettlers/22-10-06-1110.%20edge%20file/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-06-1610.%20How%20find%20barrier-face%20tip/","title":"How find barrier-face tip","text":"<p>UID:: 221006161072 Date:: 22-10-06 Creation:: Thursday 06 of October, 2022.  04:29 PM Tags:: </p> <p>Problema de implementaci\u00f3n de como encontrar una arista [[barrier-face tip]] usando la estructura 22-10-06-1610. Volume mesh data struct para la 22-06-13-1506. 3D Polylla python prototype</p> <p>Al igual que la [[Repair phase]], se puede buscar caras repetidas, de est\u00e1 forma se va a encontrar las barrier-face. </p> <p>Las propiedades que tiene una barrier-face tips son</p> <ul> <li>Es una arista</li> <li>solo una cara adyacente a est\u00e1 arista pertenece a una 22-06-01-0011. Terminal-face regions</li> </ul>"},{"location":"00%20Zettlers/22-10-06-1610.%20How%20find%20barrier-face%20tip/#idea-1","title":"Idea 1","text":"<ol> <li>Encontrar las barrier-faces buscando las caras repetidas de una terminal-face region</li> <li>Luego revisar todas las aristas de las  barrier-faces y contar la cantidad de caras que son [[Frontier-face]], si es solo una, entonces es un barrier-face tip. </li> </ol> <p>Falta analizar a\u00fan m\u00e1s el comportamiento de est\u00e1s caras en el futuro para detectarlas mejor, por ejemplo, una cara puede tener m\u00e1s de un barrier-face tip?  </p>"},{"location":"00%20Zettlers/22-10-06-1610.%20How%20find%20barrier-face%20tip/#idea-2","title":"Idea 2","text":"<p>Dado una arista \\(e\\),  con una lista de caras incidentes \\(F_e\\), perteneciente a una terminal-face \\(TF\\), con \\(L\\) siendo la lista de todas las terminal-face in \\(TF\\), se tienen los siguientes casos:</p> <ol> <li>Si \\(e\\) es un barrier-edge tip, entonces solo tiene una cara \\(f_e \\in L\\), por lo que \\(len(L) - len(f_e \\in L) = len(L) - 1\\)</li> <li>Si \\(e\\) es parte del borde de \\(TF\\), entonces no tiene ninguna cara en \\(L\\), por lo que \\(len(L) - len(f_e \\in L) = 0\\)</li> <li>Si \\(e\\) es parte de una cadena de terminal-faces, entonces \\(len(L) - len(f_e \\in L) &lt; len(L) - 1\\)</li> </ol> <p>22-10-13-1310. 3D repair phase Polylla Face 2</p>"},{"location":"00%20Zettlers/22-10-06-1610.%20How%20find%20barrier-face%20tip/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-06-1610.%20volume%20mesh%20data%20struct/","title":"volume mesh data struct","text":"<p>UID:: 221006161041 Date:: 22-10-06 Creation:: Thursday 06 of October, 2022.  04:09 PM Tags:: </p> <p>Estructura de datos usada por 22-11-07-1111. 3D Polylla Face y 22-07-06-1607. 3D Polylla Edge, en 22-06-13-1506. 3D Polylla python prototype </p> <p>Est\u00e1s estructura usa 5 structs para representar los vertices, aristas, caras y tetrahedros de una [[Tetrahedral mesh]].</p> <p>Las mallas se generan usando 22-05-31-0011. TetGen con el comando </p> <pre><code>tetgen -fzenn [filename]\n</code></pre> <p>Est\u00e1 estructura usa 5 [[array of structures (AoS)]] para representar los elements de malla, cada elemento se accede por su indice en el arreglo.</p> <p>Se prohibe cualquier calculo geom\u00e9trico en esta estructura, solo deben haber funciones topologicas. Los calculos geometricos deben ir en los correspondientes implementaciones de Polylla.</p>"},{"location":"00%20Zettlers/22-10-06-1610.%20volume%20mesh%20data%20struct/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-10-1610.%20Compile%20c%2B%2B%20windows%2010%20mingw/","title":"Compile c++ windows 10 mingw","text":"<p>UID:: 221010161080 Date:: 22-10-10 Creation::  Monday 10 of October, 2022.  04:45 PM Tags:: [[C++]]</p> <p></p>"},{"location":"00%20Zettlers/22-10-10-1610.%20Compile%20c%2B%2B%20windows%2010%20mingw/#cmake","title":"Cmake","text":"<pre><code>cmake -G \"MinGW Makefiles\" ..\n</code></pre>"},{"location":"00%20Zettlers/22-10-10-1610.%20Compile%20c%2B%2B%20windows%2010%20mingw/#make","title":"Make","text":"<pre><code>mingw32-make\n</code></pre> <p>CGAL windows</p> <pre><code> cmake -G \"MinGW Makefiles\" -DCMAKE_INSTALL_PREFIX=\"CGAL\" .\n</code></pre>"},{"location":"00%20Zettlers/22-10-13-1310.%203D%20repair%20phase%20Polylla%20Face%202/","title":"3D repair phase Polylla Face 2","text":"<p>UID:: 221013131086 Date:: 22-10-13 Creation:: Thursday 13 of October, 2022.  01:05 PM Tags:: </p> <p>Algoritmo para la 22-06-15-1106. 3D repair phase Polylla Face de 22-11-07-1111. 3D Polylla Face para detectar [[Barrier-face tip]]  </p> <pre><code>Barrier-faceDetection(terminal-face TF):\n    L = list of all repeated faces of TF (those are barrier-faces)\n    E = list of all edges of L\n    for each edge e in E\n        F_e = List of all faces incident to e\n        L1 = #(F_e in L)\n        L2 = #(L)\n        if L2 - L1 == L2 - 1:\n            e is a barrier-face tip\n</code></pre> <p>El algoritmo se basa en el principio de que para detectar barrier-faces en una 22-06-01-0011. Terminal-face regions basta con buscar las caras repetidas en esta. Y dado una arista e, solo hay una barrier-face incident a e. Ver m\u00e1s info en 22-10-06-1610. How find barrier-face tip</p> <p>Una vez dertectado las weas, se debe hacer la repair phase:</p> <pre><code>tetra_list = []\nvisited_seed_tetras_bitvector = []\nFor each barrier-face tip e in terminal-Face F:\n    calculate valence e\n    seach position of the barrier-face adjacent to e\n    select middle-face m\n    convert m into frontier-face\n    n1, n2 = tetra adjacent to m\n    add n1, n2 to tetra_list\n    visited_seed_tetras_bitvector[n1, n2] = true\n\nwhile tetra_list is not empty:\n    tetra_curr = tetra_list.pop()\n    if visited_seed_tetras_bitvector[tetra_curr] == true\n        visited_seed_tetras_bitvector[tetra_curr] = false\n        polyhedron = call DFS(tetra_curr, visited_seed_tetras_bitvector[tetra_curr])\n        polyhedral_mesh add polyhedron\n</code></pre>"},{"location":"00%20Zettlers/22-10-13-1310.%203D%20repair%20phase%20Polylla%20Face%202/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-13-1610.%20hanging%20polyhedros%20detection/","title":"3D repair phace Polylla Edge","text":"<p>UID:: 221013161013 Date:: 22-10-13 Creation:: Thursday 13 of October, 2022.  04:46 PM Tags:: </p> <p>Reparaci\u00f3n de polyhedros no simples, es decir, [[Hanging polyhedros]] por una sola arista, como este</p> <p>![[Pasted image 20221013164947.png]]</p> <p>![[socket.1POLYLLAEDGE_polyhedron_35_NONSIMPLE.off]]</p> <p>Para eliminarlos se usa un sistema de conteo, por ejemplo, sea la siguiente lista todos los tetrahedros incidentes a una arista e ordenados, donde  con el tetrahedros que le sigue:</p> <p>o: Tetrahedros pertenecientes al polyhedro x: tetrahedros que no est\u00e1n en el polyhedro</p> o o x x o x o x x o x o o x x o x <p>los cambios |o|x| suman +1 los cambios |x|o| suman +1</p> <p>por lo que si un polyhedro es no simple entonce la suma del contador es mayor a 2, que sea 2 o menor significa que todos los tetrahedros incidentes a e est\u00e1n juntos</p> <pre><code>function detect_barrier_edge(e, TE):\n    T_e = tetrahedros incidents to e\n    TE = tetrahedrons of terminal-edge region\n    for each element i of T_e that is not in TE:\n        Te[i] = -1\n    count = 0\n    for i in range(0, |T_e|):\n        first = T_e[i]\n        next = T_e[ i+1 mod |T_e]]\n        if first != -1 and next == -1 (|o|x|)\n            count += 1\n        if first == -1 and next != -1 (|x|o|)\n            count += 1\n    if count &gt; 2:\n        edge e is barrier-edge\n</code></pre> <p>Esta funci\u00f3n se debe probar en cara arista REPETIDA en el polyhedron TE</p>"},{"location":"00%20Zettlers/22-10-13-1610.%20hanging%20polyhedros%20detection/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-17-1410.%20Join%20tetrahedros%20face%20by%20incircle%20radious/","title":"Join tetrahedros face by incircle radious","text":"<p>UID:: 221017141099 Date:: 22-10-17 Creation:: Monday 17 of October, 2022.  02:27 PM Tags:: </p> <p>En 22-11-07-1111. 3D Polylla Face se puede unir las caras de los tetrahedrons usando el [[Incircle of a triangle]], la cara cuyo incircle tenga el radio m\u00e1s largo es aquel triangulo m\u00e1s equilatero de todos los tetrahedrons. </p> <p>El radio se puede calcular usando la [[Heron's formula]], sea un triangulo con lados de largo a, b y c, el radio del incircle es:</p> <p>$$ r = \\sqrt{\\dfrac{(s-a)(s-b)(s-c)}{s}} \\mbox{, donde } s = (a + b + c)/2  $$ Donde s es el [[Semiperimeter]].</p> <p>Tambi\u00e9n se puede usar el area m\u00e1xima</p>"},{"location":"00%20Zettlers/22-10-17-1410.%20Join%20tetrahedros%20face%20by%20incircle%20radious/#references","title":"References","text":"<p>Incircle and excircles of a triangle - Wikipedia</p>"},{"location":"00%20Zettlers/22-10-17-1510.%203D%20repair%20face%20Polylla%20Face%203/","title":"3D repair face Polylla Face 3","text":"<p>UID:: 221017151072 Date:: 22-10-17 Creation::  Monday 17 of October, 2022.  03:40 PM Tags:: </p> <p>Una vez detectado los barrier-face tips 22-10-06-1610. How find barrier-face tip 22-10-13-1310. 3D repair phase Polylla Face 2, </p>"},{"location":"00%20Zettlers/22-10-17-1510.%203D%20repair%20face%20Polylla%20Face%203/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-17-1510.%20Join%20criteria%203D%20polylla%20face%20comparision%20results/","title":"Join criteria 3D polylla face comparision results","text":"<p>UID:: 221017151028 Date:: 22-10-17 Creation::  Monday 17 of October, 2022.  03:21 PM Tags:: </p>"},{"location":"00%20Zettlers/22-10-17-1510.%20Join%20criteria%203D%20polylla%20face%20comparision%20results/#socket","title":"Socket","text":"<p>Info mesh:</p> <pre><code>Tetrahedral mesh info:\nNumber of nodes:  836\nNumber of faces:  5418\nNumber of tetrahedrons:  2285\nNumber of edges:  3975\n</code></pre> <p>[[Join tetrahedrons by Max area triangle]]</p> <pre><code>Number of polyhedrons: 604\nNumber of barrier faces: 431\nNumber of polyhedra with barrier faces: 135\nNumber of polyhedrons that are tetrahedrons: 96\n</code></pre> <p>22-10-17-1410. Join tetrahedros face by incircle radious</p> <pre><code>Number of polyhedrons: 283\nNumber of barrier faces: 112\nNumber of polyhedra with barrier faces: 87\nNumber of polyhedrons that are tetrahedrons: 46\n</code></pre>"},{"location":"00%20Zettlers/22-10-17-1510.%20Join%20criteria%203D%20polylla%20face%20comparision%20results/#references","title":"References","text":""},{"location":"00%20Zettlers/22-10-19-1510.%20%20vtkUnstructuredGrid%20data%20structure/","title":"vtkUnstructuredGrid data structure","text":"<p>UID:: 221019151073 Date:: 22-10-19 Creation::  Wednesday 19 of October, 2022.  03:27 PM Tags:: </p> <p>Estructura de datos de la wea de [[vtk]], se usa en 22-05-31-0011. PyVista</p> <p>![[Pasted image 20221019152732.png]]</p> <p>El array de puntos contiene las coordenadas, y el cell array contiene los indices de los cell points. El cell type contiene el tipo de cada cell.</p> <p>Las cells de VTk son:</p> <p>![[Pasted image 20221019152857.png]]</p>"},{"location":"00%20Zettlers/22-10-19-1510.%20%20vtkUnstructuredGrid%20data%20structure/#references","title":"References","text":"<p>The vtkUnstructuredGrid data structure (from the VTK Textbook [SML04]). The Points array contains point coordinates and the Cells array contains the indices of cell points. The Cell Types array contains the type of each cell and provides O ( 1 ) random access to cells. (PDF) Cache-Efficient Parallel Isosurface Extraction for Shared Cache Multicores https://kitware.github.io/vtk-examples/site/Cxx/GeometricObjects/LinearCellDemo/</p>"},{"location":"00%20Zettlers/22-11-03-1111.%20Number%20of%20polyhedrons%20in%203D%20polylla%20edge%20repair%20phase/","title":"Number of polyhedrons in 3D polylla edge repair phase","text":"<p>UID:: 221103111117 Date:: 22-11-03 Creation::  Thursday 03 of November, 2022.  11:16 AM Tags:: </p> <p>Por cada 2 cambios en 22-10-13-1610. hanging polyhedros detection hay un polyhedro. En total la cantidad de polyhedros que hay en un polyhedro no simple P es:</p> <p>Polyhedros despu\u00e9s de reparar = # cambios/2</p> <p>![[Pasted image 20221103111703.png]]</p>"},{"location":"00%20Zettlers/22-11-03-1111.%20Number%20of%20polyhedrons%20in%203D%20polylla%20edge%20repair%20phase/#references","title":"References","text":""},{"location":"00%20Zettlers/22-11-04-1711.%20Hanging%20polyhedron%20separation/","title":"Hanging polyhedron separation","text":"<p>UID:: 221104171189 Date:: 22-11-04 Creation:: Friday 04 of November, 2022.  05:12 PM Tags:: 22-07-06-1607. 3D Polylla Edge</p> <p>Basado en la implementaci\u00f3n de  22-10-13-1610. hanging polyhedros detection</p> <ul> <li>Primero se detecta la barrier-edge e, para ello se usa 22-11-04-1711. Hanging polyhedron separation</li> <li>Se copia la lista de tetrahedrons incidentes a e</li> <li>Se marcan como vacio (-1) los tetrahedros que no pertenecen al polyhedro original</li> <li>Se detecta si el primer elemento es vacio o no, de no serlo, se avanza hasta el siguiente elemento x</li> <li>Se busca el primer cambio |x|o|</li> <li>se guardan todos los tetrahedros desde el cambio |x|o| hasta el cambio |o|x|</li> <li>Se marcan todos esos tetrahedros como x</li> <li>Se busca el siguiente cambio |x|o|</li> <li>se guardan todos los tetrahedros desde el cambio |x|o| hasta el cambio |o|x|</li> <li>El ciclo termina cuando se llega al primer elemento x encontrado</li> </ul> <pre><code>function separate_hanging_polyhedrons(barrier-edge e, polyhedron P):\n    T_e = tetrahedros incidents to\n    for each element i of T_e that is not in P:\n        Te[i] = -1\n    pos_origin = position of the first element -1 in Te\n    curr = pos_origin + 1 mod |Te|\n    polyhedron_list = []\n    while curr != pos_origin:\n        if Te[curr] != -1\n            tetra_list = []\n            while curr != -1\n                add Te[curr] to tetra_list\n                curr = curr + 1 mod |Te|\n            add tetra_list to polyhedron_list\n        else:\n            curr = curr + 1 mod |Te|\n</code></pre> <p>Esta wea deber\u00eda funcionar.</p> <p>![[Pasted image 20221104174734.png]]</p> <p>Lista a probar, polyhedron 35 del ejemplo de socket</p> <pre><code>[320, -1, 2002, -1, -1, 1959]\n</code></pre>"},{"location":"00%20Zettlers/22-11-04-1711.%20Hanging%20polyhedron%20separation/#llamada","title":"Llamada","text":"<p>La llamase hace haciendo el siguiente c\u00f3digo, este c\u00f3digo se prueba con todos los polyhedros, ya que a\u00fan no se tiene un [[Function to detect if a polyhedron is not simple]].</p> <p>Se que considera la posibilidad de que un polyhedron tenga m\u00e1s de un [[Hanging polyhedron]]. Se llama a 22-10-13-1610. hanging polyhedros detection para detectar los hanging polyhedrons.</p> <pre><code>function repair_polyhedron(set of tetrahedros P):\n    edge_list = list of edges of P that repeated more of one time\n    flag = False\n    new_polyhedrons = []\n    for e in edge_list:\n        if e is a barrier-edge:\n            flag = True\n                new_polyhedrons += separate_hanging_polyhedrons(e, P)\n    if flag == True:\n        return new_polyhedrons\n    else:\n        return new_polyhedrons          \n</code></pre>"},{"location":"00%20Zettlers/22-11-04-1711.%20Hanging%20polyhedron%20separation/#references","title":"References","text":""},{"location":"00%20Zettlers/22-11-08-1711.%20Quality%20metrics%20of%20a%20mesh%20for%20VEM/","title":"Quality metrics of a mesh for VEM","text":"<p>UID:: 221108171167 Date:: 22-11-08 Creation:: Tuesday 08 of November, 2022.  05:41 PM Tags:: [[Virtual element method (VEM)]]</p>"},{"location":"00%20Zettlers/22-11-08-1711.%20Quality%20metrics%20of%20a%20mesh%20for%20VEM/#2d-mesh-quality","title":"2D mesh quality","text":"<p>En 12 se define la siguiente m\u00e9trica </p> <p>![[Pasted image 20221108180358.png]]</p> <p>![[Pasted image 20221108180422.png]]</p> <ul> <li>\\(q_1\\) es area del  [[22-11-08-1711. Kernel of a polygon]], de existir</li> <li>\\(q_2\\) es el ratio entre el area de la arista m\u00e1s peque\u00f1a de e y el m\u00e1ximo diametro dentro de la cara E. |E| es area de la cara.</li> <li>\\(q_3\\) penaliza elementos con varias aristas</li> <li>\\(q_4\\) es el minimo ratio entre la arista m\u00e1s corta y m\u00e1s larga de todas las aristas de E</li> </ul>"},{"location":"00%20Zettlers/22-11-08-1711.%20Quality%20metrics%20of%20a%20mesh%20for%20VEM/#3d-mesh-quality","title":"3D mesh quality","text":"<p>En 2 se define la siguiente m\u00e9trica de calidad</p> <p>![[Pasted image 20221108175745.png]]</p> <p>Donde: - \\(q_1\\) es el [[Polyhedron kernel]] por el [[22-11-08-1711. Kernel of a polygon]] de todas las caras - \\(q_2\\)  es el ratio del area de la cara m\u00e1s peque\u00f1a y el volumen del elemento E, m\u00e1s la m\u00e9trica \\(q_2\\) en 2D aplicada a cada cara. - \\(q_3\\) se refiere al n\u00famero de aristas y caras de un polyhedro, penaliza a los polyhedron con m\u00e1s elementos.</p>"},{"location":"00%20Zettlers/22-11-08-1711.%20Quality%20metrics%20of%20a%20mesh%20for%20VEM/#references","title":"References","text":"<ol> <li> <p>[[@sorgentePolyhedralMeshQuality2021]]\u00a0\u21a9</p> </li> <li> <p>[[@sorgenteVEMMesh2021]]\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"00%20Zettlers/22-11-08-1711.%20Star-shaped%20polygon/","title":"Star-shaped polygon","text":"<p>UID:: 221108171197 Date:: 22-11-08 Creation::  Tuesday 08 of November, 2022.  05:32 PM Tags:: [[Computational geometry]] [[Virtual element method (VEM)]]</p> <p>Es un poligono que contiene un punto, tal que se puede ver todo el borde del poligono desde ese punto1. En la imagen, z es un star point y el area roja es [[22-11-08-1711. Kernel of a polygon]]</p> <p>![[Pasted image 20221108173806.png|300]]</p> <p>En el paper2 se usa para una 22-11-08-1711. Quality metrics of a mesh for VEM</p>"},{"location":"00%20Zettlers/22-11-08-1711.%20Star-shaped%20polygon/#references","title":"References","text":"<ol> <li> <p>Star-shaped polygon - Wikipedia \u21a9</p> </li> <li> <p>: [[@sorgenteVEMMesh2021]]\u00a0\u21a9</p> </li> </ol>"},{"location":"00%20Zettlers/22-11-09-1711.%20Point%20Cloud%20Utils/","title":"Point Cloud Utils","text":"<p>UID:: 221109171130 Date:: 22-11-09 Creation::  Wednesday 09 of November, 2022.  05:12 PM Tags:: [[Python]] </p> <p>Librer\u00eda de python para trabajar con mallas de superficie. En las weas que puede hacer, es hacer el 22-11-09-1711. Poisson disk sampling.</p> <p>Tambi\u00e9n puede manger 22-06-06-1806. Triangulation y weas.</p> <p>No trabaja con malals de volumen</p>"},{"location":"00%20Zettlers/22-11-09-1711.%20Point%20Cloud%20Utils/#references","title":"References","text":"<p>P\u00e1gina: GitHub - fwilliams/point-cloud-utils: A Python library for common tasks on 3D point clouds</p>"},{"location":"00%20Zettlers/22-11-09-1711.%20Poisson%20disk%20sampling/","title":"Poisson disk sampling","text":"<p>UID:: 221109171156 Date:: 22-11-09 Creation:: Wednesday 09 of November, 2022.  05:16 PM Tags:: [[Computer graphics]]</p> <p>Forma de generar puntos en un dominio que est\u00e1n juntos, pero con una restricci\u00f3n de que no pueden m\u00e1s cerca de una distancia minima.</p>"},{"location":"00%20Zettlers/22-11-09-1711.%20Poisson%20disk%20sampling/#volume-mesh","title":"Volume mesh","text":"<p>Se pueden generar en mallas de volumen usando [[Scipy]]</p> <p>scipy.stats.qmc.PoissonDisk \u2014 SciPy v1.9.3 Manual</p>"},{"location":"00%20Zettlers/22-11-09-1711.%20Poisson%20disk%20sampling/#superficies","title":"Superficies","text":"<p>Se puede generar usando [[Scipy]] y 22-11-09-1711. Point Cloud Utils</p>"},{"location":"00%20Zettlers/22-11-09-1711.%20Poisson%20disk%20sampling/#n-dimensiones","title":"n-dimensiones","text":"<p>Se utiliza el \u00a0Bridson\u2019s algorithm mostrado en [[@bridsonFastPoissonDisk2007]]</p>"},{"location":"00%20Zettlers/22-11-09-1711.%20Poisson%20disk%20sampling/#references","title":"References","text":"<p>Poisson-Disc Sampling</p>"},{"location":"00%20Zettlers/22-11-09-1811.%20Sampling%20strategies/","title":"Sampling strategies","text":"<p>UID:: 221109181193 Date:: 22-11-09 Creation::  Wednesday 09 of November, 2022.  06:31 PM Tags:: </p> <p>Estreg\u00edas  de muestro. Si se desean generar puntos en un [[22-06-10-2206. Flat]], se tienen varias alternativas.</p> <ul> <li>Uniform sampling: Generar los puntos de manera uniforme</li> <li>22-11-09-1711. Poisson disk sampling: Poner una restricci\u00f3n a la cercan\u00eda de los puntos</li> <li>Random sampling: Poner los puntos de manera aleatoria, asegurandose de que no haya overlap.</li> <li>Disturbation sampling: Generar puntos uniformes, pero a cada punto moverlo un porcentaje aleatorio con respecto al tama\u00f1o total de todos los puntos.</li> </ul> <p>En el paper1 se definen otros 3 tipos de sampling.</p> <ul> <li>Anisotropic sampling: Puntos uniformes en dos ejes, pero un tercer eje se va aumentando la diferencia entre los puntos uniformes</li> <li>Body Centered Lattice (BCL)2: usa malla uniforme con los puntos equisdistantes, pero se agrega un punto al medio de cada cubo, para de esta manera generar tetrahedros equilateros.</li> <li>Parallel sampling: Usa un sampling uniforme, luego por cada plano de puntos se mueven todos los puntos de ese punto a otro plano.</li> </ul> <p>En el caso del paper1, estos son los ejemplos de sus sampling y las mallas que genera. ![[Pasted image 20221109184359.png]]</p> <p>![[Pasted image 20221109183357.png]]</p>"},{"location":"00%20Zettlers/22-11-09-1811.%20Sampling%20strategies/#references","title":"References","text":"<ol> <li> <p>[[@sorgentePolyhedralMeshQuality2021]]\u00a0\u21a9\u21a9</p> </li> <li> <p>GitHub - csverma610/CrystalLattice: Generate Simple Crystal Lattice: Cube, Body-Centered, Face-Centered \u21a9</p> </li> </ol>"},{"location":"00%20Zettlers/22-11-10-1711.%20Dmsh/","title":"Dmsh","text":"<p>UID:: 221110171193 Date:: 22-11-10 Creation::  Thursday 10 of November, 2022.  05:54 PM Tags:: [[Delaunay triangulation]] [[Python]]</p> <p>Generador de mallas 2d en python</p>"},{"location":"00%20Zettlers/22-11-10-1711.%20Dmsh/#references","title":"References","text":"<p>GitHub - meshpro/dmsh: Simple mesh generator inspired by distmesh.</p>"},{"location":"00%20Zettlers/22-11-10-1711.%20Meshzoo/","title":"Meshzoo","text":"<p>UID:: 221110171175 Date:: 22-11-10 Creation:: Thursday 10 of November, 2022.  05:57 PM Tags:: 22-11-10-1711. Python mesh generations libraries [[Python]] [[Delaunay triangulation]]</p> <p>Generador de mallas 2D y 3D, puede creas weas perfectamente uniformes</p>"},{"location":"00%20Zettlers/22-11-10-1711.%20Meshzoo/#references","title":"References","text":"<p>GitHub - meshpro/meshzoo: A collection of meshes for canonical domains</p>"},{"location":"00%20Zettlers/22-11-10-1711.%20Python%20mesh%20generations%20libraries/","title":"Python mesh generations libraries","text":"<p>UID:: 221110171134 Date:: 22-11-10 Creation::  Thursday 10 of November, 2022.  05:56 PM Tags:: </p> <ul> <li>22-06-01-0011. Pymesh: El mejor, pero requiere usar docker</li> <li>PyGMSH: Interfaz de GMSH, </li> </ul> <p>Estos necesitan licencia para mallas grandes:</p> <ul> <li>22-11-10-1711. Dmsh: Este genera buenas mallas</li> <li>22-11-10-1711. Meshzoo: Genera mallas estructuradas</li> <li>[[Optimesh]]: este no crea mallas, las optimiza</li> </ul>"},{"location":"00%20Zettlers/22-11-10-1711.%20Python%20mesh%20generations%20libraries/#references","title":"References","text":""},{"location":"00%20Zettlers/22-11-21-1711.%20VTK%20Polyhedron/","title":"VTK Polyhedron","text":"<p>Keywords:: [[Polyhedron]] 22-05-31-0011. PyVista</p> <p>Un polyhedron en [[vtk]] se define de la siguiente manera</p> <pre><code>[NElements, NFaces, Face1NPoints, Face1Point1, Face1Point2..., Face1PointN, FaceNNPoints,...]]\n</code></pre> <p>Donde: </p> <ul> <li>NElements:  es la cantidad de n\u00fameros que vienen adelante y definen a todo el polyhedron</li> <li>NFaces: Cantidad de caras a definir</li> <li>Face1NPoints: Cantidad de v\u00e9rtices que tiene la cara 1<ul> <li>Face1Point1, Face1Point2..., v\u00e9rtices de la cara 1</li> </ul> </li> <li>... se sigue definiendo primero la cantidad de vertices de la cara y luego los v\u00e9rtices</li> </ul> <p>Ejemplo de 22-05-31-0011. PyVista donde se usa en el m\u00e9todo [[lang.python.pyvista.UnstructuredGrid]] para definir 22-10-19-1510.  vtkUnstructuredGrid data structure. Fuente2</p> <pre><code>polyhedron = np.asarray([24, 5, 4, 2, 3, 4, 5, 4, 5, 6, 7, 4, 3, 4, 7, 3, 3, 5, 6, 2, 4, 6, 7, 3, 2])\n</code></pre> <p>Que signifca que es un polyhedron de 24 elementos, con 5 caras. dos caras de 4 v\u00e9rtices, 2 caras de 3 v\u00e9rtices y otra cara de 4 v\u00e9rtices. En v\u00e9rtical es as\u00ed</p> <pre><code>24\n5\n4, 2, 3, 4, 5\n4, 5, 6, 7, 4\n3, 4, 7, 3\n3, 5, 6, 2\n4, 6, 7, 3, 2\n</code></pre> <p>Por alguna raz\u00f3n difere de la docu oficial1 que define un Polyhedron como</p> <pre><code>[numberOfCellFaces, (numberOfPointsOfFace0, pointId0, pointId1, \u2026 ), (numberOfPointsOfFace1, pointId0, pointId1, \u2026), \u2026 ]. \n</code></pre> <p>Sin el NElements. Seguramente es debido a que se de otra manera. el NElements viene siendo el [[VTK celltype]], que es un offset, como se tiene por defecto, hay que definirlo en cada polyhedro.</p>"},{"location":"00%20Zettlers/22-11-21-1711.%20VTK%20Polyhedron/#references","title":"References","text":"<ol> <li> <p>VTK/Polyhedron Support - KitwarePublic \u21a9</p> </li> <li> <p>How do I generate an UnstructuredGrid with polyhedrons? \u00b7 Discussion #3414 \u00b7 pyvista/pyvista \u00b7 GitHub \u21a9</p> </li> </ol>"},{"location":"00%20Zettlers/22-11-23-1111.%20Union%20of%20coplanar%20faces%20in%20a%20polyhedron/","title":"Union of coplanar faces in a polyhedron","text":"<p>Keywords:: </p> <p>Algorithm for 22-10-13-1310. 3D Polylla to join coplanar faces. </p> <p>This algorithm requiere a polyhedron as a set of faces, in where each face is represented by their vertices</p> <p>este algoritmo solo funciones para unir triangulos</p> <pre><code>function remove_coplanar_faces(polyhedron):\n    for each face f_0 in polyhedron:\n        if\n        find adjacent faces f_1, f_2, f_3 to f_0\n        for each adj face f_i to f_0:\n            poly = unique vertices of (f_i, f_0)\n            if volume(poly v) == 0:\n                remove f_i and f_0 from polyhedron\n                add poly v at the end of polyhedron.face_list\n                break\n</code></pre> <p>El algoritmo crea un polygono/polyhedron con los v\u00e9rtices adjacentes a f_0, calcula su volumen es 0, entonces es un poligono, sus puntos son coplanares, si el volumen es mayor que 0, entonces es un polyhedron. </p> <p>Ver 22-11-23-1211. Calculation volume tetrahedron</p>"},{"location":"00%20Zettlers/22-11-23-1111.%20Union%20of%20coplanar%20faces%20in%20a%20polyhedron/#problemas","title":"problemas","text":"<ul> <li>hay que expandir este algoritmo para que pueda unir m\u00e1s triangulos a quadritaleos</li> <li>Puede eliminar </li> </ul>"},{"location":"00%20Zettlers/22-11-23-1111.%20Union%20of%20coplanar%20faces%20in%20a%20polyhedron/#references","title":"References","text":""},{"location":"00%20Zettlers/22-11-23-1211.%20Calculation%20volume%20tetrahedron/","title":"Calculation volume tetrahedron","text":"<p>Keywords:: [[Computational geometry]]</p> <p>Calculo del volumen de tetrahedro creado por [[Github Copilot]]. Se basa en la formula de wiki pedia1 del volumen, en la respuesta de stackoverflow2 lo explican mejor</p> <pre><code>#Calcuyalte volume of a tetrahedron given its vertices\n#https://stackoverflow.com/questions/9866452/calculate-volume-of-any-tetrahedron-given-4-points\ndef calculate_tetrahedron_volume(self, v1, v2, v3, v4):\n    av1 = np.array([v1.x, v1.y, v1.z])\n    av2 = np.array([v2.x, v2.y, v2.z])\n    av3 = np.array([v3.x, v3.y, v3.z])\n    av4 = np.array([v4.x, v4.y, v4.z])\n    return abs(np.dot(av1-av4, np.cross(av2-av4, av3-av4)))/6\n</code></pre>"},{"location":"00%20Zettlers/22-11-23-1211.%20Calculation%20volume%20tetrahedron/#references","title":"References","text":"<ol> <li> <p>Tetrahedron - Wikipedia \u21a9</p> </li> <li> <p>[[Calculate Volume of any Tetrahedron given 4 points]]\u00a0\u21a9</p> </li> </ol>"},{"location":"00%20Zettlers/22-11-23-1211.%20ale3D%20file%20format/","title":"ale3D file format","text":"<p>Keywords:: </p> <p>Formator de outout de 22-10-13-1310. 3D Polylla. </p>"},{"location":"00%20Zettlers/22-11-23-1211.%20ale3D%20file%20format/#archivo-1-unit_block_poly_elemstxt","title":"Archivo 1 unit_block_poly_elems.txt","text":"<pre><code># domain type\nCustomBoundaryDataWithTags\n\n# nodal coordinates: number of nodes followed by the coordinates\n1238\n0.6250000000000000 0.0416666666666667 0.9166666666666667\n0.0416666666666667 0.9583333333333334 0.9166666666666666\n0.9593593750000000 0.4482986111111112 0.5695138888888889\n...\n\n# face connectivity: number of faces followed by the connectivity (each line: nodes_per_face(nel) node1 node2 node3 node4)\n2678\n5 966 1207 920 160 195\n4 967 1208 966 195\n4 921 1209 920 160\n...\n\n# element connectivity: number of elements followed by the connectivity (each line: faces_per_element(nel) face1 face2 face3 face4). If a face is negative, it mean that the element use the face in the opposite direction.\n249\n7 -1 -2 3 4 2385 2386 2387\n12 1 -5 6 -7 -8 -9 -10 -11 -12 13 -2388 -2389\n10 2 5 -14 -15 -16 -17 -18 19 -2390 -2391\n10 -3 -6 -20 -21 -22 -23 24 25 -2392 -2393\n\n# indices of nodes located on the Dirichlet boundary: first line, Dirichlet nodes, second line, tags associated with the Dirichlet nodes\n727 730 731 735 737 739  ...\n\n# indices of nodes located on the Neumann boundary: first line, Neumann nodes, second line, tags associated with the Neumann nodes. ***WARNING: MUST BE ORDERED BY HAND IF NODES ARE NOT GIVEN IN CONSECUTIVE ORDER***\n729 733 734 738 740 745 754 759 763 772 776 779 781 789 791 796 797 801 810 813 826 832 836 838 840 842 852 855 863 876 900 909 915 921 940 954 959 967 969 972 990 994 1001 1009 1013 ...\n\n# xmin, xmax, ymin, ymax, zmin, zmax of the bounding box\n0.0000000000000000 1.0000000000000000 0.0000000000000000 1.0000000000000000 0.0000000000000000 1.0000000000000000\n</code></pre>"},{"location":"00%20Zettlers/22-11-23-1211.%20ale3D%20file%20format/#archivo-2-unit_block_6x6x6divstxt","title":"Archivo 2 unit_block_6x6x6divs.txt","text":"<pre><code># domain type\nCustomBoundaryDataWithTags\n# nodal coordinates: number of nodes followed by the nodal coordinates\n249\n        1.00000000000000000000         1.00000000000000000000         0.00000000000000000000 \n        1.00000000000000000000         0.83333333333333337034         0.00000000000000000000 \n...\n\n# element connectivity: number of elements followed by the connectivity (each line: nodes_per_element(nel) node1 node 2 ... node_nel)\n726\n4 211 217 229 208\n4 197 163 222 226\n4 49 65 63 62\n...\n\n# corner nodes: first line, number of nodes; following lines: node index followed by an integer (0,1,2) that indicates whether the corner node is also a Dirichlet or Neumann boundary node, i.e., 0=None, 1=Dirichlet, 2=Neumann, and an integer that can be used as a tag to assign the corresponding value (or function) of the Dirichlet or Neumann boundary condition\n11\n1 2 2\n1 1 1\n102 1 4\n103 2 2\n\n# faces containing domain boundary edges: faces containing edges located on the boundary edges of the domain and their face connectivities; first line: number of recorded faces containing a domain boundary edge; following lines: face nodal connectivity of the face that contains the boundary edge, an integer (0,1,2) that indicates whether the edge is also a Dirichlet or Neumann boundary edge, i.e., 0=None, 1=Dirichlet, 2=Neumann, and an integer that can be used as a tag to assign the corresponding value (or function) of the Dirichlet or Neumann boundary condition\n128\n197 163 222 2 2\n222 226 197 2 2\n\n# domain boundary faces: faces located on the whole boundary of the domain and their connectivities; first line: number of recorded faces on the boundary; following lines: face nodal connectivity followed by an integer (0,1,2) that indicates whether the face is also a Dirichlet or Neumann boundary face, i.e., 0=None, 1=Dirichlet, 2=Neumann, and an integer that can be used as a tag to assign the corresponding value (or function) of the Dirichlet or Neumann boundary condition\n432\n211 217 229 1 2\n222 226 197 0 1\n197 163 222 2 2\n49 65 63 1 1\n</code></pre>"},{"location":"00%20Zettlers/22-11-23-1211.%20ale3D%20file%20format/#references","title":"References","text":"<ul> <li>https://camlab.cl/wp-content/uploads/2022/06/Sebastian_Luza_Tesis_v3.pdf</li> </ul>"},{"location":"00%20Zettlers/23-01-10-1601.%20BUG%20Polylla%20two%20equilateral%20triangles%20terminal-edges/","title":"BUG Polylla two equilateral triangles terminal-edges","text":"<p>Keywords:: </p> <p>Puede que haya un bug sin soluci\u00f3n en Polylla.</p> <p>Si se tienen dos triangulos equilateros </p>"},{"location":"00%20Zettlers/23-01-10-1601.%20BUG%20Polylla%20two%20equilateral%20triangles%20terminal-edges/#references","title":"References","text":""},{"location":"00%20Zettlers/23-01-16-0801.%20Label%20phase%20sort%20vs%20no%20sort%20time%20comp/","title":"Label phase sort vs no sort time comp","text":"<p>Keywords:: Polylla [[Label phase]] 22-06-08-1606. Kernel label max edge</p> <p>cpu sin sort</p> <pre><code>Labered max edges in 0.580245 ms  \nLabeled frontier edges in 0.196218 ms  \nLabeled seed edges in 0.238961 ms\n</code></pre> <p>cpu con sort</p> <pre><code>Labered max edges in 16.0518 ms  \nLabeled frontier edges in 0.211378 ms  \nLabeled seed edges in 0.251728 ms\n</code></pre> <p>CPU con sort y distancia pre calculadas</p> <pre><code>Labered max edges in 2.76836 ms\nLabeled frontier edges in 0.199578 ms\nLabeled seed edges in 0.252958 ms\n</code></pre> <p>23-01-20-1701. Polylla sort points in label phase does not work!</p>"},{"location":"00%20Zettlers/23-01-16-0801.%20Label%20phase%20sort%20vs%20no%20sort%20time%20comp/#references","title":"References","text":""},{"location":"00%20Zettlers/23-01-16-1001.%20Table%20of%20mesh%20data%20structures/","title":"Table of mesh data structures","text":"<p>Keywords:: </p> <p>![[Pasted image 20230116103300.png]]</p>"},{"location":"00%20Zettlers/23-01-16-1001.%20Table%20of%20mesh%20data%20structures/#references","title":"References","text":""},{"location":"00%20Zettlers/23-01-20-1701.%20Polylla%20sort%20points%20in%20label%20phase%20does%20not%20work%21/","title":"Polylla sort points in label phase does not work!","text":"<p>Keywords:: Polylla 23-01-16-0801. Label phase sort vs no sort time comp</p> <p>Una forma de evitar tener hoyos en la label phase y asegurar el orden correcto de todo, es creando un arreglo ordenado de aristas y comparar los indices de las aristas en vez de su largo en as\u00ed. Esta fue idea de Xevi</p> <p>Se probo con 1 mill\u00f3n de ptos y se demoro en total 13 horas.</p> <p>![[Pasted image 20230120174213.png]]</p> <p>La label phase usada es esta</p> <pre><code>std::cout&lt;&lt;\"Calculating distances...\"&lt;&lt;std::endl;\n// Pre calculate distances of each halfedge\nstd::vector&lt;int&gt; distances(mesh_input-&gt;halfEdges());\nfor(int i = 0; i &lt; mesh_input-&gt;halfEdges(); i++){\ndistances[i] = mesh_input-&gt;distance(i);\n}\n\nstd::cout&lt;&lt;\"Creating vector to sort indices...\"&lt;&lt;std::endl;\n//Auxilary array to sort halfedges\nstd::vector&lt;int&gt; sort_max_edge(mesh_input-&gt;halfEdges());\nfor(int i = 0; i &lt; mesh_input-&gt;halfEdges(); i++){\nsort_max_edge[i] = i;\n}\nstd::cout&lt;&lt;\"Sorting halfedges...\"&lt;&lt;std::endl;\n// sort vector of halfedges using the pre calculates distances array\nstd::sort(sort_max_edge.begin(), sort_max_edge.end(), [=](int a, int b) { return distances[a] &lt; distances[b]; });\n\nstd::cout&lt;&lt;\"converting pos\"&lt;&lt;std::endl;\nstd::vector&lt;int&gt; pos_sort_edge(mesh_input-&gt;halfEdges());\nfor(int i = 0; i &lt; mesh_input-&gt;halfEdges(); i++){\npos_sort_edge[sort_max_edge[i]] = i;\n}\nstd::cout&lt;&lt;\"labeling max edges\"&lt;&lt;std::endl;\n//label max edges\nfor (int i = 0; i &lt; mesh_input-&gt;faces(); i++){\n// get halfedges of triangle\nint e1 = 3*i;\nint e2 = mesh_input-&gt;next(e1);\nint e3 = mesh_input-&gt;prev(e1);\n//compare e1, e2, e3 using vector sort_max_edge\nint e1_pos = pos_sort_edge[e1];\nint e2_pos = pos_sort_edge[e2];\nint e3_pos = pos_sort_edge[e3];\n\nint max_e = std::max({e1_pos, e2_pos, e3_pos});            max_edges[sort_max_edge[max_e]] = true;\n}\n</code></pre> <p>Y lo peor es que sigue con hoyos</p> <p>![[Pasted image 20230120174723.png]] ![[Screenshot from 2023-01-20 17-47-04.png]] Nancy recomendo que se cree el arreglo de aristas \u00fanicas (sin half-edges), pero que no se ordene</p>"},{"location":"00%20Zettlers/23-01-20-1701.%20Polylla%20sort%20points%20in%20label%20phase%20does%20not%20work%21/#references","title":"References","text":""},{"location":"00%20Zettlers/23-01-24-1201.%20Cost%20of%20pemb/","title":"Cost of pemb","text":"<p>Keywords:: [[Pemb]] Compact Polylla</p> <p>Pemb usa  la siguiente wea </p> <pre><code>                size_type m_vertices = 0;\nsize_type m_edges = 0;\nbit_vector_type m_A;\nrank_1_type m_A_rank;\nselect_1_type m_A_select1;\nselect_0_type m_A_select0;\nbit_vector_type m_B;\nbit_vector_type m_B_star;\nsucc_tree m_B_st;\nsucc_tree m_B_star_st;\n</code></pre> <p>Pemb usa</p> <p>rank_supoort_v y select mcl</p>"},{"location":"00%20Zettlers/23-01-24-1201.%20Cost%20of%20pemb/#references","title":"References","text":"<p>![[sdsl-cheatsheet.pdf]]</p>"},{"location":"00%20Zettlers/23-01-27-1201.%20Parallel%20Lepp/","title":"Parallel Lepp","text":"<p>Keywords:: </p> <p>Lepp se puede paralelizar si se inserta un punto dentro del triangulo y se refina localmente.</p>"},{"location":"00%20Zettlers/23-01-27-1201.%20Parallel%20Lepp/#references","title":"References","text":""},{"location":"00%20Zettlers/23-03-13-1703.%20Polylla%20sorted%20array%20for%20max%20edge%20label/","title":"Polylla sorted array for max edge label","text":"<p>Keywords:: </p> <pre><code>         /*\n        std::cout&lt;&lt;\"Calculating distances...\"&lt;&lt;std::endl;\n        // Pre calculate distances of each halfedge\n        std::vector&lt;int&gt; distances(mesh_input-&gt;halfEdges());\n        for(int i = 0; i &lt; mesh_input-&gt;halfEdges(); i++){\n            distances[i] = mesh_input-&gt;distance(i);\n        }\n\n\n        std::cout&lt;&lt;\"Creating vector to sort indices...\"&lt;&lt;std::endl;\n        //Auxilary array to sort halfedges\n        std::vector&lt;int&gt; sort_max_edge(mesh_input-&gt;halfEdges());\n        for(int i = 0; i &lt; mesh_input-&gt;halfEdges(); i++){\n            sort_max_edge[i] = i;\n        }\n        std::cout&lt;&lt;\"Sorting halfedges...\"&lt;&lt;std::endl;\n        // sort vector of halfedges using the pre calculates distances array\n        std::sort(sort_max_edge.begin(), sort_max_edge.end(), [=](int a, int b) { return distances[a] &lt; distances[b]; });\n\n        std::cout&lt;&lt;\"converting pos\"&lt;&lt;std::endl;\n        std::vector&lt;int&gt; pos_sort_edge(mesh_input-&gt;halfEdges());\n        for(int i = 0; i &lt; mesh_input-&gt;halfEdges(); i++){\n            pos_sort_edge[sort_max_edge[i]] = i;\n        }\n        std::cout&lt;&lt;\"labeling max edges\"&lt;&lt;std::endl;\n        //label max edges\n        for (int i = 0; i &lt; mesh_input-&gt;faces(); i++){\n            // get halfedges of triangle\n            int e1 = 3*i;\n            int e2 = mesh_input-&gt;next(e1);\n            int e3 = mesh_input-&gt;prev(e1);\n            //compare e1, e2, e3 using vector sort_max_edge\n            int e1_pos = pos_sort_edge[e1];\n            int e2_pos = pos_sort_edge[e2];\n            int e3_pos = pos_sort_edge[e3];\n\n            int max_e = std::max({e1_pos, e2_pos, e3_pos});            \n            max_edges[sort_max_edge[max_e]] = true;\n        }\n     */\n</code></pre>"},{"location":"00%20Zettlers/23-03-13-1703.%20Polylla%20sorted%20array%20for%20max%20edge%20label/#references","title":"References","text":""},{"location":"00%20Zettlers/23-03-15-1703.%202D%20Polylla%20error%20holes/","title":"2D Polylla error holes","text":"<p>Keywords:: </p> <p>Polylla tiene un error y es que si en el condicional le pongo que verifique <code>e_curr != e_init &amp;&amp; v_init != v_curr</code> genera poligonos que son solo barrier edges, esto es debido a que la la segunda parte de los vertices hace que la condici\u00f3n se haga true &amp;&amp; false = False y salga. </p> <p>Si elimino la parte de la condici\u00f3n pasa que se queda en un loop con el primer poligono que es este </p> <pre><code>10 740819 699273 561824 868559 527379 408116 54451 920627 779371 0 \n</code></pre> <p>El loop se ve as\u00ed</p> <pre><code>e_curr: 0 v_origin: 0(0,0) e_target 740819(8.07188,0)\ne_curr: 1 v_origin: 740819(8.07188,0) e_target 779371(0,13.2958)\ne_curr: 19 v_origin: 699273(25.4284,6.94758) e_target 527379(12.2141,22.1546)\ne_curr: 62 v_origin: 561824(28.9645,18.1152) e_target 527379(12.2141,22.1546)\ne_curr: 22 v_origin: 868559(28.6035,20.5362) e_target 527379(12.2141,22.1546)\ne_curr: 23 v_origin: 527379(12.2141,22.1546) e_target 561824(28.9645,18.1152)\ne_curr: 13 v_origin: 408116(0,19.5593) e_target 54451(0,19.0789)\ne_curr: 14 v_origin: 54451(0,19.0789) e_target 527379(12.2141,22.1546)\ne_curr: 7 v_origin: 920627(0,16.4372) e_target 527379(12.2141,22.1546)\ne_curr: 16 v_origin: 779371(0,13.2958) e_target 527379(12.2141,22.1546)\n</code></pre> <p>EL problema es que el v\u00e9rtices inicial no es el 0 ni el 16, sino que 18</p> <p><code>e_init: 18 v_init: 740819(8.07188,0) e_target 699273(25.4284,6.94758)</code></p> <p>Adem\u00e1s hay varios aristas que terminan en el mismo target, por qu\u00e9? por qu\u00e9 la triangulaci\u00f3n es as\u00ed</p> <p>Gr\u00e1ficado queda as\u00ed </p> <p>![[Pasted image 20230315172244.png]]</p> <p>Solucionado, al final era que la condici\u00f3n de termino hac\u00eda que la [[Travel phase]] terminara antes. y cuando se quitaba ocurria que la arista inicial nunca se visitaba de nuevo porqu\u00e9 el e_curr era el next de una fe en vez de la fe en s\u00ed</p>"},{"location":"00%20Zettlers/23-03-15-1703.%202D%20Polylla%20error%20holes/#references","title":"References","text":""},{"location":"00%20Zettlers/23-04-03-2304.%20Example%20of%20pygmsh/","title":"Example of pygmsh","text":"<p>Keywords:: </p> <pre><code>import pygmsh\n\nwith pygmsh.geo.Geometry() as geom:\n    lcar = 0.1\n    p1 = geom.add_point([0.0, 0.0], lcar)\n    p2 = geom.add_point([1.0, 0.0], lcar)\n    p3 = geom.add_point([1.0, 0.5], lcar)\n    p4 = geom.add_point([1.0, 1.0], lcar)\n    s1 = geom.add_bspline([p1, p2, p3, p4])\n\n    p2 = geom.add_point([0.0, 1.0], lcar)\n    p3 = geom.add_point([0.5, 1.0], lcar)\n    s2 = geom.add_spline([p4, p3, p2, p1])\n\n    ll = geom.add_curve_loop([s1, s2])\n    pl = geom.add_plane_surface(ll)\n\n    mesh = geom.generate_mesh()\n\nprint(mesh.cells)\n\n\n# Obtener los puntos y las celdas triangulares de la malla\ntriangulos = mesh.get_cells_type(\"triangle\")\nvertices = mesh.points\n\nplt.triplot(vertices[:,0], vertices[:,1], triangulos)\nplt.show()\n</code></pre>"},{"location":"00%20Zettlers/23-04-03-2304.%20Example%20of%20pygmsh/#intereseccion-de-polygonos","title":"Interesecci\u00f3n de p\u00f3lygonos","text":"<pre><code>with pygmsh.occ.Geometry() as geom:\n    poly1 = geom.add_polygon(\n        [\n            [0.0, 0.0],\n            [1.0, -0.2],\n            [1.1, 1.2],\n            [0.1, 0.7],\n        ],\n        mesh_size=0.1,\n    )\n\n    poly2 = geom.add_polygon(\n        [\n            [0.2, 0.2],\n            [0.8, 0.2],\n            [0.8, 0.8],\n            [0.2, 0.8],\n        ], \n        mesh_size=0.1,\n    )\n    geom.boolean_difference(poly1, poly2)        \n    mesh2 = geom.generate_mesh()\n\nplt.triplot(mesh2.points[:,0], mesh2.points[:,1], mesh2.get_cells_type(\"triangle\"))\nplt.show()\n</code></pre>"},{"location":"00%20Zettlers/23-04-03-2304.%20Example%20of%20pygmsh/#references","title":"References","text":""},{"location":"00%20Zettlers/23-04-20-1304.%20ele%20file/","title":"ele file","text":"<p>Keywords:: </p> <p>Tiene los indices de los v\u00e9rtices que generan al [[tetrahedron]]</p>"},{"location":"00%20Zettlers/23-04-20-1304.%20ele%20file/#references","title":"References","text":""},{"location":"00%20Zettlers/How%20to%20do%203d%20travel%20phase%3F/","title":"How to do 3d travel phase?","text":"<p>Creation::  Thursday 02 of June, 2022.  05:44 PM date:: 22-06-02 UID:: 220602170641 Tags:: [[3D travel phase]] </p> <ol> <li>Est\u00e1 basada en la [[GPU parallel Travel phase]], por cada cara [[Frontier-face]], se actualiza sus adjacencias de sus Half-faces (Doubly linked face list). Para esto se debe investigar m\u00e1s sobre half-faces. </li> <li>Usando [[Depth-first search (DFS)]]</li> </ol>"},{"location":"00%20Zettlers/How%20to%20do%203d%20travel%20phase%3F/#references","title":"References","text":""},{"location":"Proyectos/22-07-06-1607.%203D%20Polylla%20Edge/","title":"3D Polylla terminal-edge","text":"<p>UID:: 220706160741 Date:: 22-07-06 Creation::  Wednesday 06 of July, 2022.  04:13 PM Tags:: </p> <p>Adaptaci\u00f3n de 22-07-06-1407. Delfin 3D para generar mallas de tetrahedros. Se diferencia de 22-11-07-1111. 3D Polylla Face en que este une aristas de una [[Delaunay tetrahedralization]], mientras que Polylla 3D une usando las caras.</p> <p>Uno de los problemas de est\u00e1 versi\u00f3n es que hay que elegir un 22-07-07-1707. Join criteria for edges, para ver que aristas elegir para generar los polyhedros. Delfin 3D ordena las arista de la m\u00e1s larga a la m\u00e1s corta y las usa todas para generar los vacios, otra alternativa es buscar las [[terminal-edge]] y usarlas para generar los tetrahedrons.</p> <p>Para la implementaci\u00f3n de la estructura de datos se usa 22-10-06-1610. Volume mesh data struct</p> <p>El algoritmo tiene dos phases:</p> <ol> <li>Ordenar aristas de mayor a menor en una lista \\(L\\)</li> <li>22-07-06-1607. 3D Polylla edge DFS Por cada arista \\(e \\in L\\)  hacer un DFS que cree una lista de tetrahedros que contenga todos los tetrahedros unidos por su arista m\u00e1s larga entre ellos, usando a \\(e\\) como arista de base.</li> <li>Por cada lista de tetrahedros creada, eliminar las caras repetidas, para as\u00ed obtener un polyhedro</li> <li>22-10-13-1610. hanging polyhedros detection</li> </ol> <p>Notar que el viaje en el punto 2 se hace viajando de aritas -&gt; tetrahedros -&gt; aristas -&gt; ..., no se usan las caras.</p>"},{"location":"Proyectos/22-07-06-1607.%203D%20Polylla%20Edge/#preguntas","title":"Preguntas","text":"<ul> <li> Puede polyhedron con [[Hanging polyhedros]] tener m\u00e1s de un [[3D barrier-edge]]</li> <li> </li> </ul>"},{"location":"Proyectos/22-08-22-1608.%20Polylla%20Surface/","title":"Polylla Surface","text":"<p>UID:: 220822160890 Date:: 22-08-22 Creation:: Monday 22 of August, 2022.  04:35 PM Tags:: </p> <p>Proyecto para generar mallas Polylla. Se espera generar con este m\u00e9todo un algoritmo de 22-08-22-1608. edge collapse. </p> <p>Para criterio de edge colpase, se pueden unir los vertices de los terminal edges</p>"},{"location":"Proyectos/22-08-22-1608.%20Polylla%20Surface/#references","title":"References","text":""},{"location":"Proyectos/22-10-13-1310.%203D%20Polylla/","title":"3D Polylla","text":"<p>UID:: 221013131055 Date:: 22-10-13 Creation::  Thursday 13 of October, 2022.  01:17 PM Tags:: [[22-04-14-0011. Mesh generation]]</p> <p>Version 3D del mallador 22-10-13-1310. 3D Polylla, toma como input una [[Tetrahedral mesh]] y genera una [[Polyhedral mesh]] con [[arbitrary shape]] polyhedrons. Se tienen dos versiones, dependiendo si de desea unir por arista o por caras</p> <ul> <li>22-11-07-1111. 3D Polylla Face: Versi\u00f3n directa de polylla, etiqueta cada cara de una tetrahedral mesh por su 22-07-07-1707. Joining criteria method y luego usa un 22-06-02-0011. Depth-first search (DFS) para unir los tetrahedros</li> <li>22-07-06-1607. 3D Polylla Edge: Conversi\u00f3n de [[Delfin]] 3D, necesita generar una lista ordenada de aristas, el orden depende del 22-07-07-1707. Join criteria for edges y por cada arista hace un 22-06-02-0011. Depth-first search (DFS)</li> </ul>"},{"location":"Proyectos/22-10-13-1310.%203D%20Polylla/#preguntas","title":"Preguntas","text":"<ul> <li>Es necesario unir caras coplanares? esto podr\u00eda llevar a eliminar v\u00e9rtices</li> <li>Las m\u00e9tricas de FEM sirven como 22-07-07-1707. Joining criteria method</li> </ul>"},{"location":"Proyectos/22-11-07-1111.%203D%20Polylla%20Face/","title":"3D Polylla Face","text":"<p>Creation::  Wednesday 01 of June, 2022.  07:56 PM date:: 22-06-01 UID:: 220601190612 Tags:: [[22-04-14-0011. Mesh generation]] Polylla</p> <p>Generador de [[Polyhedral mesh]], es la versi\u00f3n extendida a 3D de Polylla, en vez [[Terminal-edge region]], utiliza 22-06-01-0011. Terminal-face regions Dado una [[Tetrahedral mesh]] \\(\\tau = (V, E, F)\\), etiqueta cada cara la mesh en 3 clasificaciones de acuerdo al [[Area of a triangle]]:</p> <ul> <li>[[Internal-face]]: Cara que no es la m\u00e1s grande de ninguno de los dos tetrahedrons adyacentes</li> <li>[[Terminal-face]]: Cara que es la m\u00e1s larga de dos tetrahedrons adyacentes </li> <li>[[Frontier-face]]: Cara que no es la m\u00e1s grande de dos tetrahedrons adyacentes</li> </ul> <p>Es posible generar est\u00e1 malla en tiempo lineal con respecto a la cantidad de vertices de la malla inicial. 22-06-02-0011. 3D Polylla Face time complexity.</p> <p>Para generar la malla inicial se utilizan 3 phases 22-06-01-0011. 3D polylla Face phases.</p>"},{"location":"Proyectos/22-11-07-1111.%203D%20Polylla%20Face/#preguntas","title":"Preguntas","text":"<ul> <li>Qu\u00e9 criter\u00edos de uni\u00f3n pueden generar la mayor cantidad de poligonos con la menor cantidad de tetrahedros solos?</li> <li>Buscar m\u00e1s criterios de uni\u00f3n, actualmente se tienen dos<ul> <li>22-10-17-1410. Join tetrahedros face by incircle radious</li> <li>[[Join tetrahedrons by Max area triangle]]</li> </ul> </li> <li>Demostrar que la uni\u00f3n no genera overlap</li> <li>Demostrar que se usan todos los v\u00e9rtices</li> </ul>"},{"location":"Proyectos/Compact%20Polylla/","title":"Compact Polylla","text":"<p>Creation::  Friday 03 of June, 2022.  04:30 PM date:: 22-06-03 UID:: 220603160654 Tags:: </p> <p>Proyecto para generar versi\u00f3n comprimida de Polylla. Se trabaja con colaboraci\u00f3n con [[22-06-13-1406. Jos\u00e9 Fuentes-Sep\u00falveda]].</p> <p>Para la generaci\u00f3n de Polylla se utiliza [[Pemb]][^1], una estructura compacta para grafos planares. </p> <ul> <li> #todo Leer y resumir papers relacionados a compact half-edges</li> <li> #todo Leer [[@aleardiArraybasedCompactData2018]] y resumir</li> <li> #todo Leer [[@alumbaughCompactArrayBasedMesh2005]] y resumir</li> <li> #todo Leer [[@damiandStrippedHalfedgeData2021]] y resumir</li> <li> #todo Leer [[@danovaroHalfedgeTreeCompact2005]] y resumir</li> <li> #todo mejorar estado del arte de esta wea, tri-to-polygon mesh generation en el paper</li> </ul>"},{"location":"Proyectos/Compact%20Polylla/#links","title":"Links","text":"<ul> <li>Overleaf espa\u00f1ol completo </li> <li>Overleaf versi\u00f3n ingl\u00e9s a medio</li> <li>GitHub - ssalinasfe/Compress-Polylla-Mesh</li> </ul>"},{"location":"Proyectos/Compact%20Polylla/#references","title":"References","text":""},{"location":"Proyectos/GPolylla%20%28GPU%20polylla%29/","title":"GPolylla (GPU polylla)","text":"<p>Creation::  Thursday 26 of May, 2022.  09:24 PM date:: 22-05-26 UID:: 220526210518 Tags:: Polylla [[22-04-19-0011. Parallel Computing]]</p> <p>Versi\u00f3n paralela GPU de Polylla. Est\u00e1 versi\u00f3n fue enviada como un workshop y publicada  como research note en SIAM International Meshing Roundtable Workshop \u00bb Home. </p> <p>Se est\u00e1 trabajando en una nueva versi\u00f3n con el investigador [[22-06-02-0011. Roberto Carrasco]] </p> <p>Al igual que Polylla tiene 2 fases</p> <ul> <li>22-06-07-1706. GPU Label phase</li> <li>22-05-26-0011. GPU parallel Travel phase</li> </ul> <p>A\u00fan no se descubre como hacer la [[GPU repair phase]]</p>"},{"location":"Proyectos/GPolylla%20%28GPU%20polylla%29/#todo","title":"TODO","text":"<ul> <li> Crear repo</li> <li> convertir Polylla a GPU<ul> <li> Cambiar vector a arreglo</li> </ul> </li> <li> Optimizar con share memory</li> <li> Hacer la 22-05-26-0011. GPU parallel Travel phase</li> <li> 22-08-10: Cambiar construcci\u00f3n de half-edge, para que no cree los half-edge de borde</li> </ul>"},{"location":"Proyectos/GPolylla%20%28GPU%20polylla%29/#links","title":"Links","text":"<ul> <li>Versi\u00f3n antigua mostrada en SIAM22 GitHub - ssalinasfe/CUDA-Terminal-edge-mesh</li> </ul>"},{"location":"Proyectos/GPolylla%20%28GPU%20polylla%29/#references","title":"References","text":"<ul> <li>Link donde se muestra el horario donde se presento SIAM International Meshing Roundtable Workshop \u00bb SIAM IMR22: Registration &amp; Schedule</li> </ul>"},{"location":"Proyectos/Polylla/","title":"Polylla","text":"<p>[!INFO] date::  Saturday 16 of April, 2022 (22-04-16) Hour: 03:06 AM date:: 22-04-16 Title: Proyecto Polylla 2D UID:: 220416030456</p> <p>Tags:: [[Proyecto]] [[Phd in computing]]</p> <p>Polylla is a polygon mesh generator that generate mesh with polygon of arbitrary shape, it is based on the concept of terminal-edge region. </p> <ul> <li>22-05-27-1138. Tiempos y memoria Polylla</li> </ul>"},{"location":"Proyectos/Polylla/#links","title":"Links","text":"<ul> <li>Versi\u00f3n half-edge GitHub - ssalinasfe/Polylla-Mesh-DCEL</li> <li>Versi\u00f3n basada en caras GitHub - ssalinasfe/Polylla-Mesh</li> <li>Paper publicado POLYLLA: polygonal meshing algorithm based on terminal-edge regions | SpringerLink</li> <li>Arxiv [2201.11925] POLYLLA: Polygonal meshing algorithm based on terminal-edge regions</li> </ul>"},{"location":"Proyectos/Polylla/#preguntas","title":"Preguntas","text":"<ul> <li>Dado un poligono Polylla, su triangulazaci\u00f3n es igual a al conjunto de triangulos que lo generaron?</li> <li>Refinar una polygono polylla, va a generar subpolygonos dentro del mismo poligono o usara triangulos al rededor de este?</li> </ul>"}]}